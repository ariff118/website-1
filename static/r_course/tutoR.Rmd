---
title    : Reproducible data treatment with R
subtitle : An introduction
author   : Colin Bousige
date     : "`r format(Sys.time(), '%d/%m/%Y')`"
url      : 'https\://colinbousige.github.io/r_course/'
output: 
    bookdown::gitbook:
      self_contained: FALSE
      fig_caption : TRUE
      fig_number : TRUE
      config:
        toc:
          collapse: subsubsection
          scroll_highlight: yes
          before: |
            <li><a href="https://colinbousige.github.io/r_course/about-the-class.html">Reproducible data treatment with R</a></li>
          after: <br><br><br><br>
        toolbar:
          position: fixed
        edit : null
        download: [["tutoR.Rmd","Rmd"]]
        search: yes
        fontsettings:
          theme: white
          family: sans
          size: 2
        sharing: no
---

<!-- 
Render with:
bookdown::render_book("tutoR.Rmd")

Header:
---
title    : Reproducible data treatment with R
subtitle : An introduction
author   : Colin Bousige
date     : "`r format(Sys.time(), '%d/%m/%Y')`"
url      : 'https\://colinbousige.github.io/r_course/'
output: 
    bookdown::gitbook:
      self_contained: FALSE
      fig_caption : TRUE
      fig_number : TRUE
      config:
        toc:
          collapse: subsection
          scroll_highlight: yes
          before: |
            <li><a href="https://colinbousige.github.io/r_course/about-the-class.html">Reproducible data treatment with R</a></li>
          after: null
        toolbar:
          position: fixed
        edit : null
        download: [["tutoR.Rmd","Rmd"]]
        search: yes
        fontsettings:
          theme: white
          family: sans
          size: 2
        sharing: no
---
-->

# About the class {-}


## Objectives of the class {-}

The goal of this class is that at the end, the students are able to:

- Treat their data with the **free** and **open source** language **[R](https://www.r-project.org/)**, *i.e.*:
    + Read, browse, manipulate and plot their data
    + Model or simulate their data
- Make automatic reporting through **[Rmarkdown](https://rmarkdown.rstudio.com/)** and/or **[Jupyter notebooks](https://jupyter.org/)**
- Build a graphical interface with **[Shiny](https://shiny.rstudio.com/)** to interact with their data and output something (a value, a pdf report, a graph...)



## Prerequisites {-}

- Coding skills: none expected
- The students should come with a laptop with admin rights (*i.e.* you should be able to install stuff)



## Teaser {-}

```{r setup, include=FALSE, warning = FALSE, cache=FALSE}
setwd("/Users/colin/Travail/Enseignements/R/")
remove(list = ls())
library(plotly)
library(ggplot2)
load("plot_data.Rdata")
```

**You want to be able to produce interactive plots like these in an automatic experimental report?**

```{r, echo=FALSE}
p
ggplotly(PparRBM)
remove(list = ls())
```

<br>
**You want to produce publication-quality graphs like these?**

|                         |                               |                          |
|:-----------------------:|:-----------------------------:|:-------------------------|
| [![](Plots/data_RBM.png)](Plots/data_RBM.png) |  [![](Plots/Grt_CS07_0.5.png)](Plots/Grt_CS07_0.5.png)  | [![](Plots/Fig2epskT.png)](Plots/Fig2epskT.png) |

<br>
**You want to be able to build graphical interfaces like this to help you in your data treatment?**

![](Plots/shiny.png)

**Stay tuned! You've come to the right place.**


## Further reading {-}

This class is indented to provide the students with the tools to handle themselves with R, Rmarkdown and Shiny, and not to provide an extensive review of everything that is possible with R. To go further:

- **R**
    + [R manual on CRAN](https://cran.r-project.org/doc/manuals/r-release/R-intro.html)
    + [A digested version](https://perso.esiee.fr/~courivad/R/index.html)
    + Some [cheatsheets](https://www.rstudio.com/resources/cheatsheets/)
    + The tidyverse [website](https://ggplot2.tidyverse.org/)
    + [Tibbles](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).
- **Plotting**
    + The [R Graph Gallery](https://www.r-graph-gallery.com/)
    + The [R Graph Cookbook](https://r-graphics.org/index.html)
    + The [ggplot cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf)
        * [Another one](http://r-statistics.co/ggplot2-cheatsheet.html)
        * [Another one](http://www.sthda.com/english/wiki/be-awesome-in-ggplot2-a-practical-guide-to-be-highly-effective-r-software-and-data-visualization) quite extensive
        * [Another one](http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html)
- **Rmarkdown**
    + Rmarkdown [cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)
    + Rmarkdown [cookbook](https://dr-harper.github.io/rmarkdown-cookbook/index.html)
    + Rmarkdown [code chunks](https://bookdown.org/yihui/rmarkdown/r-code.html)
    + Rmarkdown mixing [languages](https://bookdown.org/yihui/rmarkdown/language-engines.html)
- **Shiny**
    + The Shiny [cheatsheet](https://shiny.rstudio.com/images/shiny-cheatsheet.pdf)
    + Guide to application [layout](https://shiny.rstudio.com/articles/layout-guide.html)
    + The [Shiny Gallery](https://shiny.rstudio.com/gallery/): find what you want to do and adapt it to your needs
    + The official [Shiny video tutorial](https://shiny.rstudio.com/tutorial/)
- And as always, if you have a question, [Google](https://www.google.fr/search?source=hp&ei=g0MLXeGwKNLPgweV04-IBA&q=r+how+to&oq=r+how+to) is your friend!


## Motivations {-}


### Reproducible data treatment: why it matters {-}

An introduction from the [wikipedia](https://en.wikipedia.org/wiki/Reproducibility#Reproducible_research) page on reproducible research:

> In 2016, Nature conducted a survey of 1576 researchers who took a brief online questionnaire on reproducibility in research. According to the survey, more than 70% of researchers have tried and failed to reproduce another scientist's experiments, and more than half have failed to reproduce their own experiments. [...] Although 52% of those surveyed agree there is a significant 'crisis' of reproducibility, less than 31% think failure to reproduce published results means the result is probably wrong, and most say they still trust the published literature.[^1]

[^1]: [https://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970](https://www.nature.com/news/1-500-scientists-lift-the-lid-on-reproducibility-1.19970)

*Replicability* and *reproducibility* are some of the keys to **scientific integrity**. Establishing a workflow in which your data are always treated in the same manner is a **necessity**, because it is a way to:

- **Minimize errors** inherent to human manipulation
- **Keep track** of all the treatments you perform on your data and document your methodology: this allows others to reproduce your data, but also *yourself*.
- Help you to **make sense** of all your data, and avoid disregarding some data (hence help you keep your scientific integrity)
- **Gain tremendous amounts of time**

It is the objective of this class to provide you the tools necessary to work within this philosophy.


### Why with R and not python? {-}

The eternal question... [R](https://www.r-project.org/) was originally designed by statisticians for statisticians and in my opinion suffers from this "statistics only" label that sticks to it. 

[Python](https://www.python.org/) is a __wide spectrum__ programming language with very efficient numerical libraries used in the computer science community. 

R is __focused on data treatment__, statistics and representation. In R, _**the object is the data**_, and base R allows you to read, treat, fit and plot your data very easily – although you will still most certainly need additional packages.

So with python, you can do everything, including treating and analyzing scientific data – with the right packages. With R, you can do less but do very well what you do, and in my opinion more seamlessly (probably because I learned and used R for years before starting with python...).

Each language has his own strengths and weaknesses. To my tastes, I would say that python and R compare like that (although a pythonist would probably say the opposite):

|                                      |                    R                     |          Python          |
|:------------------------------------:|:----------------------------------------:|:------------------------:|
|         Free and open source         |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|                 IDE                  |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|        Large code repository         |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|           Large community            |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|              Notebooks               |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|           Machine Learning           |         &#10004;&#10004;&#10004;         | &#10004;&#10004;&#10004; |
|             Performances             |                 &#10004;                 | &#10004;&#10004;&#10004; |
| Ease of installation and maintenance |         &#10004;&#10004;&#10004;         |         &#10004;         |
|          Data visualization          |         &#10004;&#10004;&#10004;         |         &#10004;         |
|         Statistical analysis         |         &#10004;&#10004;&#10004;         |         &#10004;         |
|            Multi-purpose             |                 &#10004;                 | &#10004;&#10004;&#10004; |
|  Syntax, productivity, flexibility   |                 &#10004;                 | &#10004;&#10004;&#10004; |
|              Rmarkdown               | &#10004;&#10004;&#10004;&#10004;&#10004;&#10004;&#10004;&#10004;&#10004;&#10004; |         &#10004;         |

Well, it's all very subjective, really.
In the end, *I still use both languages*, each one for a different purpose:

- Let's say I want to produce an initial atomic configuration for a molecular dynamics simulation, or read a molecular dynamics trajectory and compute some quantities such as a pair correlation or a mean square displacement: **python** (or even _C_, if I need to treat large trajectories).
- Now if I want to make sense of some experimental measurements or results of simulations, do some fits and produce publication-quality graphs or experimental reports: **R**.

Both languages are great and being able to use both is the best thing that can happen to you (relatively speaking) – _especially since you can combine them in Rmarkdown using the [reticulate](https://rstudio.github.io/reticulate/) package_, which we will see later in this class. 

So, since my goal is to provide you with tools for seamlessly read, make sense, and plot your data in the reproducible science philosophy, let's go with __R__.



# Getting ready

## The easy way


- [Download](https://cran.r-project.org/) and install R
- [Download](https://www.rstudio.com/products/rstudio/download/#download) and install Rstudio
- You're good to go.

Launch Rstudio, click `File > New File > R script`. 

Write whatever you want in the "Source code" panel, and __run__ it by selecting it and hitting ⌘+⏎ (Ctrl+⏎ on Windows). If no text is selected, hitting ⌘+⏎ will launch the current line. 

The code output will be seen in the "R Console" panel if it's a text, or in the "Graph" panel if it's a graph. A list of all defined variables and functions is available in the "Environment" panel.

[![](Plots/rstudio.png)](Plots/rstudio.png)

More on the [Rstudio cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf).

## The more advanced way


If you don't want to use Rstudio but rather want to keep with your favorite text editor, like I do[^2]  ([Sublime Text](https://www.sublimetext.com/3), [Atom](https://atom.io/), [Visual Studio Code](https://code.visualstudio.com/)...)

- I still recommend [downloading](https://cran.r-project.org/) and installing R via CRAN (I had some packages problems due to a homebrew installation).
- To be fully operational with Rmarkdown files without using Rstudio, you need to install `pandoc`:
```bash
brew install openssl
brew install pandoc
brew install pandoc-citeproc
pip install pandoc-eqnos
pip install pandoc-fignos
pip install pandoc-tablenos
```

[^2]: I personally use [Sublime Text 3](https://www.sublimetext.com/3) with the following packages:<br>
<ul>
    <li>First, install [Package control](https://packagecontrol.io/installation)</li>
    <li>Set up command line launch: <br>`ln -s "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl" \`<br>` /usr/local/bin/sublime`</li>
    <li>Packages to install (_a minima_):</li>
    <ul>
        <li>R-box</li>
        <li>SublimeREPL</li>
        <li>SendCode</li>
    </ul>
    <li>And also:</li>
    <ul>
        <li>LatexTools</li>
        <li>BracketHighlighter</li>
        <li>CiteBibtex</li>
        <li>wordcount</li>
        <li>Path Tools</li>
        <li>SidebarEnhancements</li>
    </ul>
</ul>
To be able to send code from a code chunk in Rmarkdown to the REPL window, click `Preferences > Browse Packages`, and then open `Packages/SublimeREPL/config/R/Main.sublime-menu`.<br><br>
Find the option `"additional_scopes"` and change it into:<br><br>
`"additional_scopes": ["HTML.markdown.rmarkdown","tex.latex.knitr"],`<br><br>
Save the file, close the REPL tab, restart ST3, and open a new REPL instance.


## In any case: install LaTeX


A **full** $\LaTeX$ distribution (emphasis on **full**) will be needed to knit markdown files to PDFs:

- Windows: go [here](https://miktex.org/download) and download the Net Installer to install the **complete distribution**
- Mac: go [here](https://tug.org/mactex/mactex-download.html) or type `brew cask install mactex` in the terminal if you have [Homebrew](https://treehouse.github.io/installation-guides/mac/homebrew) installed
- Linux: [here](https://dzone.com/articles/installing-latex-ubuntu) fore example


## Setting up the environment



Make sure you have the following packages installed by launching (⌘+⏎ or Ctrl+⏎) the following commands:
```r
install.packages("rstudioapi")
install.packages("devtools")
install.packages("tools")
install.packages("tidyverse")
install.packages("rmarkdown")
install.packages("knitr")
install.packages("shiny")
install.packages("FME")
```

Later on, a package can be loaded by calling:
```r
library(package_name)
```
or by checking it in the "Graph" panel under the "Packages" tab.
If you want to access a function from a given package without loading it (or because several packages define the same function and you want to specify which to use), type:
```r
package_name::function_name(parameters)
```
If you want to access the documentation on a given package, click the link on this package in the "Packages" tab.
In a more general way, help on a function is accessed by typing in `?function_name`, the help appearing in the "Graph" panel.


To get the path of your working environment, type in:
```{r}
getwd()
```

To set it to the directory you want:
```r
setwd("your/path/")
```

To set it to the directory the current file is in, type in:
```r
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
```


# Simple variables

In R, the variable attribution is done through the arrow operator `<-` instead of the `=` one – for historical reasons. The equal sign, `=`, would still work though, but you should just take up the habit of using `<-`.

In reality, scalar numbers don't exist in R, they are simply 1 element vector: this is why `[1]` is printed in the following outputs.

## Scalars and booleans


Separate in-line instructions with a `;` or just skip a line. 
Different ways of defining a scalar, as a `double` or an `integer`:
```{r, warnings=FALSE}
x <- 1; x
typeof(x)
class(x)
y <- floor(1.2); y; typeof(y); class(y)
z <- as.integer(1.2); z; typeof(z); class(z)

```

### Special values
R handles infinity, NaN, and has $\pi$ defined. Missing numbers are handled through the `NA` keyword.
```{r, warnings=FALSE}
pi; 10/0; -10/0; 0/0; is.na(NA)
```

### Booleans
Booleans are handled with the `TRUE` and `FALSE` keywords. Any number non 0 is equivalent to TRUE, 0 is FALSE.
```{r, warnings=FALSE}
z <- TRUE; typeof(z)
as.logical(1)
as.logical(0)
x == y # is equal
x != y # is not equal
x < y  # is smaller than
x <= y # is smaller or equal than
x == y & x < y  # operator "and"
x == y || x < y # operator "or"
```

### Complex values
```{r, warnings=FALSE, error=TRUE}
1+i
1+1i
exp(1i*pi)
sqrt(-1)
sqrt(-1 + 0i)
Im(exp(1i*pi))
```

## Strings


A string is defined between quotation marks `"string"`. Here are some operations on strings :
```{r, warnings=FALSE, error=TRUE}
phrase <- " Hello World " # definition of a string
paste("phrase =", phrase, ", class(phrase) =", class(phrase))
substr(phrase, 2, 5) # sub-string
paste(tolower(phrase), toupper(phrase), sep=" - ") # change case
sub("o", "a", phrase)  # change the first occurrence of "o" in "a"
gsub("o", "a", phrase) # change all occurrences of "o" in "a"
trimws(phrase)         # trim white spaces
phrase2 <- "1234"
phrase2 - 4321             # won't work: string - double
as.numeric(phrase2) - 4321 # conversion of string to double
```

For more complex operations, see the [stringr](https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html) package or the [string cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/strings.pdf).

## Exercises


What will be the output of the following entries?



```{r}
x <- "100"; y <- 99.6; 
```


```r
x - ceiling(y)
```

<details>
<summary>Show output</summary>

```{r, warnings=FALSE, error=TRUE, echo=FALSE}
x - ceiling(y)
```

</details>
<br>

```r
1 / sin(as.numeric(x) - ceiling(y))
```

<details>
<summary>Show output</summary>

```{r, warnings=FALSE, error=TRUE, echo=FALSE}
1 / sin(as.numeric(x) - ceiling(y))
```


</details>
<br>

```r
cos(pi/2)==cos(3*pi/2)
```

<details>
<summary>Show output</summary>

```{r, warnings=FALSE, error=TRUE, echo=FALSE}
cos(pi/2)==cos(3*pi/2)
```

</details>
<br>

```r
cos(pi/2)-cos(3*pi/2)
```

<details>
<summary>Show output</summary>

```{r, warnings=FALSE, error=TRUE, echo=FALSE}
cos(pi/2)-cos(3*pi/2)
```

</details>
<br>

```r
all.equal(cos(pi/2),cos(3*pi/2))
```

<details>
<summary>Show output</summary>

```{r, warnings=FALSE, error=TRUE, echo=FALSE}
all.equal(cos(pi/2),cos(3*pi/2))
```

</details>



# Vectors

**R is a vectorized language** with built-in arithmetic and relational operators, mathematical functions and types of number. It means that each mathematical function and operator works on a set of data rather than a single scalar value as traditional computer language do, and thus __formal looping can _usually_ be avoided__.

## Different ways of defining a vector


```{r, warnings=FALSE}
x <- c(1,5,3,12,4.2,"skdjnc"); x # x is a vector of strings
x <- c(1,5,3,12,4.2); x # x is a vector of doubles
1:10
1:10*.1  # no need to loop on the elements to multiply them!
1:10 + 1:10*.5 # or to add/subtract/multiply vectors
1:10*1:10
seq(-10,10,by=.5)
seq(-10,10,length=6)
seq(-10,10,along=x)
rep(0,10)
rep(c(0,2), 5)
rep(c(0,2),each=5)
rnorm(10, mean=3, sd=1) # vector with 10 random values
```

## Principal operations on vectors


```{r, warnings=FALSE}
x <- c(1,5,3,12,3,4.2)
y <- c(a=0,b=2,c=1,d=9,e=10,f=-1) # each element can be named
x; y
names(x);names(y)
```
### Accessing values
__!!! In R, indexes numbering start at 1 !!!__
```{r, warnings=FALSE}
# accessing by indexes
x[1]; y[4]; 
# accessing by name
y[c('b','d')]; y[['c']]
# access index 1, 5 and 2
x[c(1,5,2)] 
# remove elements 1 and 3
x[-c(1,3)] 
```
### Sorting
```{r, warnings=FALSE}
# ascending
sort(x) 
# descending
sort(x, decreasing = TRUE) 
# find the order of the indexes of the sorting
order(x); x[order(x)]
# find duplicates
duplicated(x)
# remove duplicates
unique(x)
# choose 3 random values
sample(x, 3)
```
### Maximum and minimum
```{r, warnings=FALSE}
# maximum of x and its index
x; max(x); which.max(x) 
# minimum of y and its index
y; min(y); which.min(y)
# range of a vector
range(x)
```
### Mathematical operations
```{r, warnings=FALSE, error=TRUE}
x + 2             # addition of a value to all elements
x*2               # multiplication / division
x%/%3             # integer division
sqrt(abs(cos(x))) # math functions apply on all elements
x^2.5             # power
x*y               # multiplication of vectors of the same size
x*1:2             # multiplication of vectors of different sizes
x%%2              # modulo
x %o% y           # outer product of vectors (the result is a matrix)
```
### Statistics on vectors
```{r, warnings=FALSE}
length(x)  # size of vector
summary(x) # statistics on vector
sum(x)     # sum of all terms
mean(x)    # average value
median(x)  # median value
sd(x)      # standard deviation
table(x)   # count occurrence of values
```
### More stuff
```{r, warnings=FALSE}
# cumulative sum
cumsum(x)
# term-by-term difference
diff(x)
# reverse order
rev(1:5)
# append values
append(x, 4)    # at the end
append(x, 4, 3) # or after a given index
# concatenate vectors
z <- c(-1:4, NA, -x); z
# find NA values
is.na(z); anyNA(z)
# remove NA values (operator "!" means "is not")
z <- z[!is.na(z)]; z
# returns a vector of the indexes verifying the condition
z==2; which(z==2)
# positive values of z
z; z>0; z[z>0]; z[which(z>0)]
```


## Exercises


<details>
<summary>**Exercise 1**</summary>

Consider two vectors, x, y:
```r
x <- 1:5
y <- seq(0, 4, along=x)
```

Without typing it into Rstudio, what are the values of `x`, `y`, and `x*y`?

</details>

<details>
<summary>**Exercise 2**</summary>

Consider two vectors, a, b

```r
a <- c(1,5,4,3,6)
b <- c(3,5,2,1,9)
```
What is the value of: `a<=b`?

</details>

<details>
<summary>**Exercise 3**</summary>

If 
```r
x <- c(1:12)
```
What is the value of: `length(x)`

</details>

<details>
<summary>**Exercise 4**</summary>

If 
```r
a <- c(12:5)
```
What is the value of: `is.numeric(a)`

</details>

<details>
<summary>**Exercise 5**</summary>

Consider two vectors, x, y
```r
x <- c(12:4)
y <- c(0,1,2,0,1,2,0,1,2)
```
What is the value of: `which(!is.finite(x/y))`?


</details>

<details>
<summary>**Exercise 6**</summary>

Consider two vectors, x, y
```r
x <- letters[1:10]
y <- letters[15:24]
```
What is the value of: `x<y`?

</details>

<details>
<summary>**Exercise 7**</summary>

If 
```r
x <- c('blue','red','green','yellow')
```
What is the value of: `is.character(x)`?

</details>

<details>
<summary>**Exercise 8**</summary>

If 
```r
x <- c('blue',10,'green',20)
```
What is the value of: `is.character(x)`?

</details>

<details>
<summary>**Exercise 9**</summary>

Assign value 5 to variable x.

Is there a difference between `1:x-1` and `1:(x-1)` ?

Explain.

</details>

<details>
<summary>**Exercise 10**</summary>

Generate the sequence `9, 18, 27, 36, 45, 54, 63, 72, 81, 90` in 4 different manners.

</details>

<details>
<summary>**Exercise 11**</summary>

If `x <- c("w", "h", "f", "g", "k")`, what will be the output for `x[c(2,3)]`?

1. "h", "f"
1. "h"
1. "f"

What will be the third value in the index vector operation `x[c(2, 4, 4)]`?

1. "h"
1. NA
1. "g"

What will be the fourth value in the index vector operation `x[-2]`?

1. "h"
1. "g"
1. "k"


</details>

<details>
<summary>**Exercise 11**</summary>

Let `a <- c(2, 4, 6, 8)` and `b <- c(TRUE, FALSE, TRUE, FALSE)`.

What will be the output for the R expression `max(a[b])`?


</details>


<details>
<summary>**Exercise 12: Case Application**</summary>

(adapted from [here](https://perso.esiee.fr/~courivad/R/05-vectors.html#application-population-in-french-cities-1962-2012))

Open Rstudio and create a new R script, save it as `population.R` in your wanted directory, say `Rcourse/`.


<a href="Data/population.csv" download target="_blank">Download</a> the `population.csv` file and save it in your working directory.

A csv file contains raw data stored as plain text and separated by a comma (Comma Separated Values). Open it from a text editor, as Excel and the likes don't work well with csv files.

We can of course directly load such file with R and store its data in an appropriate format (_i.e._ a `data.frame`), but this is for a next section. For now, just copy-paste the text in the Rstudio script area to:

- Create a `cities` vector containing all the cities listed in `population.csv`
- Create a `pop_1962` and `pop_2012` vectors containing the populations of each city at these years. Print the 2 vectors. 
- Use names() to name values of `pop_1962` and `pop_2012`. Print the 2 vectors again. Are there any change?
- What are the cities with more than 200000 people in 1962? For these, how many residents in 2012?
- What is the population evolution of Montpellier and Nantes?
- Create a `pop_diff` vector to store population change between 1962 and 2012
- Print cities with a negative change
- Print cities which broke the 300000 people barrier between 1962 and 2012
- Compute the total change in population of the 10 largest cities (as of 1962) between 1962 and 2012.
- Compute the population mean for year 1962
- Compute the population mean of Paris
- Sort the cities by decreasing order of population for both years
- Check to see which cities changed rank during these years (check out the `match` function).

<details>
<summary>Solution</summary>

```{r, warnings=FALSE}
# Create a `cities` vector containing all the cities listed in `population.csv`
cities <- c("Angers", "Bordeaux", "Brest", "Dijon", "Grenoble", "Le Havre", 
            "Le Mans", "Lille", "Lyon", "Marseille", "Montpellier", "Nantes", 
            "Nice", "Paris", "Reims", "Rennes", "Saint-Étienne", "Strasbourg", 
            "Toulon", "Toulouse")
# Create a `pop_1962` and `pop_2012` vectors containing the populations 
# of each city at these years. Print the 2 vectors. 
pop_1962 <- c(115273,278403,136104,135694,156707,187845,132181,239955,
              535746,778071,118864,240048,292958,2790091,134856,151948,
              210311,228971,161797,323724)
pop_2012 <- c(149017,241287,139676,152071,158346,173142,143599,228652,
              496343,852516,268456,291604,343629,2240621,181893,209860,
              171483,274394,164899,453317)
pop_1962; pop_2012
# Use names() to name values of `pop_1962` and `pop_2012`. 
# Print the 2 vectors again. Are there any change?
names(pop_2012) <- names(pop_1962) <- cities
pop_1962; pop_2012
# What are the cities with more than 200000 people in 1962? 
# For these, how many residents in 2012?
cities200k <- cities[pop_1962>200000]
cities200k; pop_2012[cities200k]
# What is the population evolution of Montpellier and Nantes?
pop_2012['Montpellier'] - pop_1962['Montpellier']; pop_2012['Nantes'] - pop_1962['Nantes']
# Create a `pop_diff` vector to store population change between 1962 and 2012
pop_diff <- pop_2012 - pop_1962
# Print cities with a negative change
cities[pop_diff<0]
# Print cities which broke the 300000 people barrier between 1962 and 2012
cities[pop_2012>300000 & pop_1962<300000]
# Compute the total change in population of the 10 largest cities
# (as of 1962) between 1962 and 2012.
ten_largest <- cities[order(pop_1962, decreasing = TRUE)[1:10]]
sum(pop_2012[ten_largest] - pop_1962[ten_largest])
# Compute the population mean for year 1962
mean(pop_1962)
# Compute the population mean of Paris
mean(c(pop_1962['Paris'], pop_2012['Paris']))
# Sort the cities by decreasing order of population for both years
(pop_1962_sorted <- sort(pop_1962, decreasing = TRUE))
(pop_2012_sorted <- sort(pop_2012, decreasing = TRUE))
# Check to see which cities changed rank (and by how much) 
# during these years (check out the `match` function).
ranked_cities <- match(names(pop_1962_sorted),names(pop_2012_sorted)) - seq_along(cities)
names(ranked_cities) <- names(pop_1962_sorted)
ranked_cities
```


</details>
</details>



# Lists

Lists allow you to store all types of objects and types of values: booleans, doubles, characters, vectors, other lists, data.frame, etc
```{r, warnings=FALSE}
# initialization
L <- list(name = "John",
          age  = 43,
          kids = list(name=c("Kevin", "Pamela"), # nested list
                      age =c(4,5)
                     )
         )
L
# names of entries (can be changed)
names(L)
# statistics
summary(L)
# accessing values, with the subtleties
L$name # is a vector
L["age"];typeof(L["age"])     # is a list
L[["age"]];typeof(L[["age"]]) # is a vector
L[[3]]      # is a list (because 'kids' is a list)
L[[3]]['name']   # is a list
L[[3]][['name']] # is a vector
# empty initialization
LL <- list(); LL # no specific size
LL <- vector("list", length=3); LL # specific size
# Concatenation
L1 <- list(wife="Kim", wife.age=38)
L2 <- c(L, L1)
typeof(L2); L2
```




# Data frames

## Defining a data.frame


In R, the principal object is *the data*. Hence the `data.frame` object, which is basically a table of vectors. A `data.frame` is a list presented under the form of a table – *i.e.* a spreadsheet. On a day-to-day basis, you will either define `data.frame` from existing vectors or other `data.frame`, or define a `data.frame` from a file (text, Excel...). In this example, we use <a href="Data/test.dat" download target="_blank">test.dat</a> and <a href="Data/test.xlsx" download target="_blank">test.xlsx</a>.

```{r, warnings=FALSE, message=FALSE}
# x = 10 random numbers between -10 and 10
x  <- runif(10, min=-10, max=10) 
y  <- sin(x)
df <- data.frame(x,y) # df is a data.frame (a table)
df
# dimension of df
dim(df)
# first and last 3 values
head(df, 3); tail(df, 3)
# statistics on df
summary(df)
# changing column name
df <- data.frame(xxx=x,yyy=y)
head(df,2)
colnames(df) <- c("thisISx","THISisY")
head(df,2)
# from a matrix
A <- matrix(1:9,ncol=3)
as.data.frame(A)
# from a file
read.table("Data/test.dat")            # default column name is V1, V2, V3, etc
read.table("Data/test.dat",header=TRUE)# use first line as column names
read.table("Data/test.dat",skip=1)     # skip first line. 
# ?read.table for more options
library(readxl) # load readxl from tidyverse to read Excel files
read_excel("Data/test.xlsx", sheet=1)
read_excel("Data/test.xlsx", sheet=2)
```

## Accessing values 

```{r, warnings=FALSE}
# column number
df[,1] # this is a vector
# column name
df$thisISx; df[,"THISisY"] # a vector too
# first row; row 1 to 3
df[1,]; df[1:3,]; 
# through conditions
df[x<0 & y>0, ]  # Here x and y are vectors, not the column names
df[ df[,"thisISx"]<0 & df[,2]>0, ]  # conditions on columns
# subsetting using column names
subset(df, thisISx>2 & THISisY>0, select = c(thisISx))
```

## Adding columns or rows

```{r, warnings=FALSE}
# Adding columns
df   <- data.frame(x,y)
df$z <- (df$x)^2; df
data.frame(df,w=1:length(x), xx=NA, yy=1, zz=1:2)
cbind(df, data.frame(a=1:length(x), b=1:length(x)) )
# Adding rows
rbind(df, df)     # with a data.frame
rbind(df, df[1,]) # with a vector
# deleting rows/columns
df[-1,]
df[,-1]
```

## More on data.frame


### More math operations
Almost everything that we saw on the operations on vectors are basically applicable to the `data.frame` object.

### Tidy up!

**A good practice in R is to *tidy* your data.** R follows a set of conventions that makes one layout of tabular data much easier to work with than others. Your data will be easier to work with in R if it follows three rules:

- Each variable in the data set is placed in its own column
- Each observation is placed in its own row
- Each value is placed in its own cell

Data that satisfies these rules is known as tidy data. Example:

```r
df <- read.csv("Data/population.csv")
df # is not tidy
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
df <- read.csv("Data/population.csv")
df # is not tidy
```

</details>

```r
library(tidyr)
df <- gather(df, names(df)[-1], key="city", value="pop")
df #is tidy
```

<details>
    <summary>Show output</summary>

```{r echo=FALSE, message=FALSE}
library(tidyr)
df <- gather(df, names(df)[-1], key="city", value="pop")
df #is tidy
```

</details>

```r
spread(df, city, pop) # is not tidy
```
<details>
    <summary>Show output</summary>

```{r echo=FALSE}
spread(df, city, pop) # is not tidy
```

</details>

</details>




You can find more information on data import and [tidyness](https://garrettgman.github.io/tidying/) on the [data-import cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-import.pdf).

### Tibbles

A `tibble` is an enhanced version of the `data.frame` provided by the `tidyverse` package. The main advantage of `tibble` is that it shows better performance than `data.frame` for large datasets, and it has easier initialization and nicer printing. Otherwise, the handling is basically the same.

More on tibbles [here](https://cran.r-project.org/web/packages/tibble/vignettes/tibble.html).

```{r, include=FALSE}
rm(x)
```

```{r, error=TRUE, warnings=FALSE, message=FALSE}
library(tidyverse)
tibble(x=runif(1e3), y=cumsum(x))
data.frame(x=runif(1e3), y=cumsum(x))
```



## Exercises


<details>
<summary>**Exercise 1**</summary>

Create a 3 column `data.frame` containing 100 random values, their sinus, and the sum of the two first columns.

Do the same with a `tibble`

</details>

<details>
<summary>**Exercise 2**</summary>

Download <a href="Data/population.txt" download target="_blank">population.txt</a> and load it into a `data.frame`.

- Are the data tidy?
- What are the names of the columns?
- Create a subset containing the data for Montpellier
    + What is the max and min of population in this city?
    + The average population over time?
- What is the total population in 2012?

<details>
<summary>Solution</summary>

```{r}
# Download population.txt and load it into a `data.frame`.
popul <- read.table("Data/population.txt", header=TRUE)
# Are the data tidy?
head(popul)
# What are the names of the columns and the dimension of the table?
names(popul); dim(popul)
# Create a subset containing the data for Montpellier
mtp <- subset(popul, city=="Montpellier")
#     What is the max and min of population in this city?
range(mtp[,"pop"])
#     The average population over time?
mean(mtp[,"pop"])
# What is the total population in 2012?
sum(popul[popul[,"year"]==2012, "pop"])
```


</details>

</details>





# Functions

## Definition

To get the manual on a base function, type `?function_name`.

A function returns the last thing that is called in it:
```{r, warnings=FALSE}
geom_mean <- function(x, y){
    a <- sqrt(x*y)
}
geom_mean(1,2) #returns nothing
geom_mean <- function(x, y){
    a <- sqrt(x*y)
    a
}
geom_mean(1,2) #returns a
```

The result of a function can be a list, a data.frame, a vector... or nothing. And you can attribute the result of a function to a variable:

```{r, warnings=FALSE}
person <- function(name, age){
    list(name=name, age=age)
}
joe <- person(name="Joe", age=33)
joe
```

One can add default values to variables:
```{r, warnings=FALSE}
testfunc <- function(x,y=1){
    x*y
}
testfunc(1)
testfunc(1,y=2)
testfunc(1:3,y=.1)
```

And pass arguments to other functions:
```{r, warnings=FALSE}
testfunc2 <- function(x,...){
    head(x,...)
}
testfunc2(1:100)
testfunc2(1:100,2)
```

Or even pass a function as argument:
```{r, warnings=FALSE}
testfunc3 <- function(FUN,...){
    FUN(...)
}
testfunc3(sum,1:10)
testfunc3(plot, 1:10, sin(1:10), type="l")
```


## Interpolation of data

It is possible to interpolate data through the `approxfun()` and `splinefun()` functions: while the former uses linear interpolation, the latter uses cubic splines (polynomials).

```{r}
x  <- c(1:10, 15:30)
xx <- seq(1, 30, .1)
y  <- sin(x)
# Linear interpolation
linear_interp <- approxfun(x,y)        #is a function
yy_lin        <- approx(x, y, xout=xx) #is a list containing x and y
# Cubic spline interpolation
spline_interp <- splinefun(x,y)        #is a function
yy_spline     <- spline(x, y, xout=xx) #is a list containing x and y

par(family = "Helvetica", cex.lab=1.5, cex.axis=1.4, 
    mgp = c(2.4, .5, 0), tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(x, y, pch=16, cex=2)
lines(xx, linear_interp(xx), col="royalblue")
# equivalent to: lines(yy_lin, col="royalblue")
lines(xx, spline_interp(xx), col="red")
# equivalent to: lines(yy_spline, col="red")
```


## Exercises

**Exercise 1**

Write a function returning a `tibble` (created if not supplied, incremented if supplied) containing the name, age and gender of the people in the class. Print it.

<details>
<summary>Solution</summary>

```{r, warnings=FALSE}
library(tidyverse)
people <- function(ppl=tibble(), name, age, gender){
    rbind(ppl, tibble(name=name, age=age, gender=gender))
}
ppl <- people(name="Colin", age=33, gender="Male")
ppl <- people(ppl=ppl, name="Vincent", age=39, gender="Male")
ppl
```

</details>

<br>
<br>

**Exercise 2**

Create the sinus cardinal function, $f(x)=\sin(x)/x$ for $x\neq0$ and $f(0)=1$.

<details>
<summary>Solution</summary>

```{r, warnings=FALSE, fig.asp=.85}
sinc <- function(x, tol = sqrt(.Machine$double.eps) ){
    # sinus cardinal
    y <- rep(1,length(x))
    b <- which(abs(x)>tol)
    y[b] <- sin(x[b])/x[b]
    y
}
sinc(seq(-pi,pi,pi/4))
x <- seq(-8*pi,8*pi,.1)
plot(x, sinc(x), type="l", lwd=3);abline(h=0,v=0)
```

</details>



# Conditional actions and loops


## Conditional actions

Conditional actions in R can be determined through the usual `if then else` statements:
```{r}
x <- 1; y <- 2
if(x>y){
    print("x is larger than y")
}else if(x<y){
    print("x is smaller than y")
}else{
    print("x is equal to y")
}
# if else in on line
x <- rnorm(5, mean=5)
ifelse(x>5, "larger than 5", "lower than 5") 
```


## Loops...

Loops in R are provided through the usual `for` and `while` keywords:

```{r}
# For loop
for(i in 1:100){
    # pass to next index directly
    if(i %in% c(3,8,5)) next 
    # break loop
    if(i==10) break
    print(i)
}
phrase <- c("hello", "world")
for(word in phrase){
    print(word)
}
# While loop
i <- 1
while(i<8){
    print(i)
    i <- i+2
}
```

## ... and how to avoid them

However, since R is a vectorized language, it means that loops are to be avoided when possible because they are very inefficient:

```{r}
test_time <- function(FUN,...) {
    start_time <- Sys.time()
    FUN(...)
    elapsed_time <- Sys.time()-start_time
    print(paste("Elapsed time :", elapsed_time, "s - ",
                as.character(substitute(FUN)))
         )
}
forloop <- function(x){
    for(i in seq_along(x)){
        x[i] <- 2*x[i]
    }
    x
}
noforloop <- function(x){
    2*x
}
x <- runif(1e8)
test_time(forloop, x); test_time(noforloop, x)
```

Avoiding loops should therefore be though for when possible. R helps us in this way through the base functions `apply`, `sapply` and `lapply`. 

Take a look at the help on these functions, but the summary is that `apply(df, direction, function)` applies a function in the wanted direction (1 for rows, 2 for columns) of the given `data.frame` (or vector). Example:

```{r, message=FALSE}
library(tidyverse)
dt <- tibble(x=1:5, y=x^2, z=x^3);dt
apply(dt, 1, mean) # mean of the rows
apply(dt, 2, mean) # mean of the columns
```

`lapply` (and equivalently, `sapply`) is basically the same thing but applied to lists and it returns a list (a vector):
```{r}
my_list <- list(dt/3, dt/5);my_list
lapply(my_list, "[", 1, )  # print first row
sapply(my_list, rowSums)   # sum on rows
lapply(my_list, round, 1)  # round to first decimal
# For more complex operations, use it this way:
sapply(1:nrow(dt), function(i){
    dt$x[i] + dt$y[(i+2)%%nrow(dt)+1] - dt$z[(i+4)%%nrow(dt)+1]
})
```



## Exercises


<details>
    <summary>**Exercise 1**</summary>

Given `x <- runif(1e3, min=-1, max=1)`, create a `tibble` like this one:

```{r, echo=FALSE}
tibble(x = runif(1e3, min=-1, max=1), 
       y = ifelse(x>0, "x>0", "x<=0"))
```

</details>




<details>
    <summary>**Exercise 2**</summary>

Given:

```r
LL <- list(A = runif(1e2),
           B = rnorm(1e3),
           C = data.frame(x=runif(1e2), y=runif(1e2))
           )
```

Print the sum of each element of `LL` in a list, in a vector.

<details>
    <summary>Solution</summary>

```{r, warnings=FALSE}
LL <- list(A = runif(1e2),
           B = rnorm(1e3),
           C = data.frame(x=runif(1e2), y=runif(1e2))
           )
lapply(LL, sum)
unlist(lapply(LL, sum)); sapply(LL, sum)
```

</details>
</details>


<details>
    <summary>**Exercise 3**</summary>

- Download <a href="Data/population.csv" download target="_blank">population.csv</a> and load it into a `data.frame`
- What is the total population over the years?
- What is the mean population for each city?


<details>
    <summary>Solution</summary>

```{r}
# Download population.csv and load it into a `data.frame`
df <- read.csv("Data/population.csv")
# What is the total population over the years?
data.frame(year=df[,"Année"],
           pop =rowSums(df[,-1]),     # a first way
           pop2=apply(df[,-1], 1, sum)# another way
          )
# A tidy-compatible version 
popul <- gather(df, names(df)[-1], key="city", value="pop")
popul %>%
  group_by(Année) %>%
  summarise(totpop = sum(pop))
# or equivalently
summarise(group_by(popul, Année), totpop = sum(pop))
# What is the mean population for each city?
apply(df[,-1], 2, mean)
summarise(group_by(popul, city), totpop = mean(pop))
```

</details>
</details>




# Plotting



**Now that we have seen most of the basics, let's start the fun stuff !**

There are two main ways to plot data in R:

- Using base graphics, the native R plotting device
- Using the package `ggplot2` and tidy data frames

`ggplot2` is extremely powerful and some people advise not even teaching base graphics to beginners. But I find that some times it's just quicker/easier with base graphics, so I will still present it, although not in full details.


## Base graphics


### Basic plotting
```{r, warnings=FALSE}
x  <- seq(-3*pi,3*pi,length=1000)
y  <- sinc(x)
z  <- sinc(x)^2
df <- data.frame(x=x, y=y)
plot(x,y) # plot providing x and y data
plot(df)  # plot providing a two-columns data.frame
df <- data.frame(x=x, y=y, z=z, w=z*y)
plot(df)  # plot providing a multi-columns data.frame
```

### Adding some style
OK, easy. Now let's do some tuning of this, because it's a tad ugly...
Type in each command and see what they do.
```{r, warnings=FALSE}
# create some fake data
x  <- seq(-3*pi,3*pi,length=100)
df <- data.frame(x=x, y=sinc(x), z=sinc(x)^2)
# add some styling parameters
par(family = "Helvetica", cex.lab=1.5, cex.axis=1.4, 
    mgp = c(2.4, .5, 0), tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(df$x,df$y,
     type = "l",     # "l" for lines, "p" for points
     xlab = "X values",
     ylab = "Intensity",
     axes = FALSE,
     main = "Some Plot"
    )
# vertical line in 0
abline(v=0,lty=2,lwd=2)
# horizontal line in 0
abline(h=0,lty=3,lwd=2)
# line with coefficients a (intercept) and b (slope)
abline(a=0,b=.1,lty=4,lwd=1)
# add a line
lines(df$x,df$z,type = "l",col="red",lwd=3)
# add points
points(df$x,df$z*df$y,col="royalblue",pch=16,cex=1)
# add custom axis. 
# Default with axis(1);axis(2);axis(3, labels=FALSE);axis(4, labels=FALSE);
# Bottom
axis(1,at=seq(-10,10,2),labels=TRUE,tck=0.02)
axis(1,at=seq(-10,10,1),labels=FALSE,tck=0.01); # small inter-ticks
# Top
axis(3,at=seq(-10,10,2),labels=FALSE)
axis(3,at=seq(-10,10,1),labels=FALSE,tck=0.01); # small inter-ticks
# Left
axis(2,at=seq(-1,1,.2),labels=TRUE)
axis(2,at=seq(-1,1,.1),labels=FALSE,tck=0.01); # small inter-ticks
# Right
axis(4,at=seq(-1,1,.2),labels=FALSE)
axis(4,at=seq(-1,1,.1),labels=FALSE,tck=0.01); # small inter-ticks
# Draw a box
box()
# Print legend
legend("topleft",
    cex=1.4, #size of text
    lty=c(1,1,NA),   # type of line (1 is full, 2 is dashed...)
    lwd=c(1,3,NA),   # line width
    pch=c(NA,NA,16), # type of points
    col=c("black","red","royalblue"), # color
    bty = "n", # no box around legend
    legend=c("sinc(x)",expression("sinc(x)"^2),expression("sinc(x)"^3))
    )
```

Most needs should be covered with this simple plot that can be adapted.

A plot can be exported if surrounded by `XXX` and `dev.off()`, with `XXX` that can be `pdf("xxx.pdf",height=6, width=8)`, `png("xxx.png",height=6, width=8)`... Example:
```r
pdf("test.pdf",height=6, width=8)
plot(x,y,
     type="l",
     xlab="x"
     )
dev.off()
```

You can also export the graph as a `.tex` file using `tikz`, which allows you to use $\LaTeX$ mathematical expressions (don't forget to escape the `\` character):
```r
library(tikzDevice)
tikz("plot.tex",height=6, width=8,pointsize = 10,standAlone=TRUE)
plot(x,y,
     type="l",
     xlab="\\omega_i"
     )
dev.off()
```

### Going further

#### Panel plots

Lets create a plot with different panels (a bit ugly without styling, you need to tweak the margins and text distance to plot with `par(mar(), mgp())` before each plot):



```{r, fig.height=6, fig.width=6}
# some fake data
x  <- seq(-10,10,1)
d1 <- data.frame(x=x, y=sin(x))
d2 <- data.frame(x=x, y=sinc(x))
d3 <- data.frame(x=x, y=exp(-x^2)*sinc(x)^2)
# creating the layout and styling
M  <- matrix(c(c(1,1),c(2,3)), byrow=TRUE, ncol=2); M
nf <- layout(M, heights=c(1), widths=c(1))
# first plot
plot(d1,type="l")
# second plot
plot(d2,type="p")
# third plot
plot(d3,type="b")
```

```{r, fig.height=6, fig.width=6}
# creating the layout and styling
M  <- matrix(c(c(1,1),c(2,3)), byrow=FALSE, ncol=2); M
nf <- layout(M, heights=c(1), widths=c(1))
# first plot
plot(d1,type="l")
# second plot
plot(d2,type="p")
# third plot
plot(d3,type="b")
```

#### Barplots and densities


```{r, warnings=FALSE}
x <- rnorm(1e4, mean = 0, sd = 1)
# Barplot
hist(x)
# Density
y  <- density(x, bw=0.1) # small kernel bandwidth
y2 <- density(x, bw=0.5) # larger kernel bandwidth
plot(y, lwd=2, main="", xlab="X values", xlim=c(-4,4))
lines(y2,col="red",lwd=2)
points(x, jitter(rep(.01,length(x)), amount=.01), 
        cex=1,pch=16, col=adjustcolor("royalblue", alpha=.01))
```



## Advanced plotting using ggplot2

Further (more detailed) reading [here](http://tutorials.iq.harvard.edu/R/Rgraphics/Rgraphics.html) and on the [cheatsheet](https://github.com/rstudio/cheatsheets/raw/master/data-visualization-2.1.pdf) for example.

`ggplot2` is a package (now even available for python) that completely changes the methodology of plotting data. With `ggplot2`, data are gathered in a **tidy** `data.frame`, and each column can be used as a parameter to tweak colors, point size, etc.

First things first, load the library:
```r
library(ggplot2)
```

### A quick plot

A quick plot can be made using the function `qplot` (for "quickplot"), very similar to the base graphics `plot` function. It's great for allowing you to produce plots quickly, but it is highly recommended learning `ggplot()` as it makes it easier to create complex graphics. 

Note how different is the default theme of the plot:

```r
# some fake data
x  <- seq(-10,10,.5)
y  <- sinc(x)
p1 <- qplot(x,y, geom="line") # ggplot2 quick plot
p2 <- qplot(x,y, geom="point") # ggplot2 quick plot
p1; p2
```
```{r, echo=FALSE, warnings=FALSE, message=FALSE}
# some fake data
x  <- seq(-10,10,.5)
y  <- sinc(x)
p1 <- qplot(x,y, geom="line") # ggplot2 quick plot
p2 <- qplot(x,y, geom="point") # ggplot2 quick plot
library(cowplot)
theme_set(theme_grey())
plot_grid(p1,p2, labels=c("P1", "P2"))
```


### The grammar of graphics

With `ggplot2` is introduced the notion of "grammar of graphics" through the function `ggplot()`. What it means is that the plots are built through independent blocks that can be combined to create any wanted graphical display.
To construct a plot, you need to provide building blocks such as:

- data gathered in a *tidy* data.frame
- an *aesthetics* mapping: what column is *x*, *y*, the color, the size, etc...
- geometric object: points, lines, bars...
- statistical transformations
- scales
- coordinate system
- position adjustments
- faceting

Since a figure is worth a thousand words, let's get to it. We will use the dataset `diamonds` built-in with the `ggplot2` package. Let's have a look:

```{r, warnings=FALSE}
diamonds
```

`diamonds` contains 53940 lines and 10 columns in a `tibble` (which is basically a `data.frame` with more advanced properties, let's not get into it for now). `ggplot` can easily handle such large dataset.

Let's say we want to see whether there is a correlation between price and weight (carat) of the diamonds:

```{r, warnings=FALSE}
p <- ggplot(data=diamonds,aes(x=carat,y=price))
p + geom_point()
```

OK, we're onto something, but we can probably add some information to this plot. We will first cut the data above 3 carats because they are not relevant, and add some transparency to the points to see some statistical information.

```{r, warnings=FALSE}
p <- ggplot(data=subset(diamonds, carat<=3),
            mapping=aes(x=carat,y=price))
p + geom_point(alpha=0.1)
```

Let's now see whether the clarity plays a role here by coloring the points according to the diamonds cut:
```{r, warnings=FALSE}
p <- ggplot(data=subset(diamonds, carat<=3),
            mapping=aes(x=carat,y=price, color=cut))
p + geom_point(alpha=0.1)
```

It looks like the price dispersion is homogeneous, we can make sure by adding a spline smoothing:
```{r, warnings=FALSE}
p + geom_point(alpha=0.1) + geom_smooth()
```

The slope evolution shows that in general, the better the cut, the higher the price. But there are some discrepancies that may be explained in another manner:
```{r, warnings=FALSE}
p <- ggplot(data=subset(diamonds, carat<=3),
            mapping=aes(x=carat,y=price, color=clarity))
p + geom_point(alpha=0.1) + geom_smooth()
```

It is often easier to grasp a multi-variable problem by plotting all our data in a facet plot using `facet_wrap()`
```{r, warnings=FALSE}
colors <- rainbow(length(unique(diamonds$clarity)))
p <- ggplot(diamonds, aes(x=price,y=carat)) + 
        geom_point(aes(color=clarity), alpha=0.5, size=1) + 
        geom_smooth(color="black") + 
        scale_colour_manual(values = colors, name="Clarity") +
        facet_wrap(~cut) 
p
```

Or by adding another graphical parameter such as the size of the points:
```{r, warnings=FALSE}
p <- ggplot(diamonds, aes(x=price,y=carat, size=cut)) + 
        geom_point(aes(color=clarity), alpha=0.5) + 
        scale_colour_manual(values = colors, name="Clarity")
p
```

OK, maybe not here because the graph gets clogged, so we can lighten it by sampling data:
```{r, warnings=FALSE}
p <- ggplot(diamonds[sample(1:dim(diamonds)[1], size=500),], 
            aes(x=carat,y=price, size=cut)) + 
        geom_point(aes(color=clarity), alpha=0.5) + 
        scale_colour_manual(values = colors, name="Clarity")
p
```

### Theming

It is very easy to keep the same theme on all your graphs thanks to the `theme` function.
There are a collection of pre-defined themes, like:
```{r, warnings=FALSE}
p + theme_grey() # the default
p + theme_classic()
p + theme_bw()
p + theme_minimal()
p + theme_dark()
p + theme_light()
```

You can define all the parameters you want, like this (hit `?theme` like usual to see all the parameters):

```{r, warnings=FALSE}
my_theme <- theme_bw()+
            theme(axis.text = element_text(size = 14,family = "Helvetica",colour="black"),
                  text = element_text(size = 14,family = "Helvetica"),
                  axis.ticks = element_line(colour = "black"),
                  legend.text = element_text(size = 14,family = "Helvetica",colour="black"),
                  panel.border = element_rect(colour = "black", fill=NA, size=1),
                  legend.key.height=unit(0.5,"cm")
                  )
p + my_theme
```

### Making interactive plots with ggplot2 and plotly

Thanks to the `plotly` package, it is really easy to transform a `ggplot` plot into an interactive plot:
```{r, include=FALSE, warning = FALSE, message=FALSE}
library(plotly)
```
```r
# load plotly
library(plotly)
```
```{r, warnings=FALSE}
p <- ggplot(diamonds[sample(1:dim(diamonds)[1], size=100),], 
        aes(x=carat,y=price)) + 
        geom_point(aes(color=clarity), alpha=0.5, size=2) + 
        my_theme
ggplotly(p)
```


### Gathering plots on a grid

If you have several plot you want to gather on a grid and you can't use `facet_wrap` (because they come from different data sets), you can use the library `cowplot` and its function [plot_grid()](https://cran.r-project.org/web/packages/cowplot/vignettes/plot_grid.html):

```{r, message=FALSE}
library(cowplot)
p1 <- qplot(1:10, sin(1:10))
p2 <- qplot(1:10, cos(1:10))
p3 <- qplot(1:10, tan(1:10))
theme_set(theme_grey()) # to keep the theme_grey
plot_grid(p1, p2, p3, labels=c("a)","b)","c)"), ncol=3)
```



## 3D color plots

You may want to plot your data as a color map, like the evolution of a Raman spectrum as a function of temperature, pressure or position. In some cases you'll have a 3-columns `data.frame` with x, y, and z values (_e.g._ intensity of a peak as a function of the position on the sample), in some cases you can have a list of spectra evolving with a given parameter. 

### The ggplot2 solution

Let's create a dummy set of spectra that we will gather in a tidy `tibble`.

```{r, message=FALSE}
Nspec <- 40                           # Amount of spectra
T     <- seq(273, 500, length=Nspec)  # Fake Temperatures
N     <- 500                          # Size of the x vector
library(tidyverse)
fake_data <- tibble()                     # Empty tibble (for performance)
for (i in 1:Nspec) {
    # Let's create dummy x and y values
    # You would normally use a read.table here 
    x  <- seq(0, 100, length = N)
    y  <- 50*dnorm(x, mean= (T[i]/T[1])*20 + 25, sd = 10+runif(1,max=5) )
    fake_data <- rbind(fake_data, tibble(w=x, Intensity=y, T=T[i]) )
}
fake_data
```

OK, so now we have some fake experimental data stored in a tidy `tibble` called `fake_data`. We want to plot it as a color map in order to grasp the evolution of the spectra:

```{r, out.width='100%', message = FALSE, fig.asp=.7,cache=FALSE}
# Plotting
colors <- colorRampPalette(c("white","royalblue","seagreen",
                             "orange","red","brown"))(500)
P1 <- ggplot(data=fake_data, aes(x=w, y=T, fill=Intensity)) + 
          geom_raster() + #geom_tile would work to
          ggtitle("Some fake data") + 
          scale_fill_gradientn(colors=colors,name="Intensity\n[arb. units]") +
          labs(x = "Fake Raman Shift [1/cm]",y="Fake Temperature [K]") +
          theme_bw()
ggplotly(P1)
# Some other way : a stacking of plots 
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
fake_data$offset <- norm01(fake_data$Intensity) + rep(1:length(T)-1, each=length(x))
colors <- colorRampPalette(c("royalblue","seagreen","orange","red","brown"))(Nspec)
P2 <- ggplot(data=fake_data, aes(x=w, y=offset, color=T, group=T)) + 
          geom_line() + 
          labs(x="Fake Raman Shift [1/cm]", y="Fake Intensity [arb. units]") +
          scale_color_gradientn(colors=colors) +
          coord_cartesian(xlim = c(25,75)) +
          theme_bw()
ggplotly(P2)
```




### The base graphics solution

In some cases you end up with a matrix _z_, and two vectors _x_ and _y_. This is easy to plot using the base `image` function. For the sake of example, let's just use the `acast` function on our melted 3-columns data.frame:

```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(reshape2)
z <- acast(data.frame(fake_data), x~T, value.var="Intensity")
x <- unique(data.frame(fake_data)[,"w"])
y <- unique(data.frame(fake_data)[,"T"])
x <- x[order(x)]
y <- y[order(y)]
colors <- colorRampPalette(c("white","royalblue","seagreen","orange","red","brown"))(500)
par(mar=c(4, 4, .5, 4), lwd=2)
image(x,y,z,col = colors)
```
You can add a legend by using the `image.plot` function:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(fields)
par(mar=c(4, 4, .5, 4), lwd=2)
image.plot(x,y,z, col = colors)
```


### The plotly solution

And finally, if you want to make this an interactive plot, you can use `plotly`:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.6,cache=FALSE}
library(plotly)
aX <- list(title = "Raman Shift [1/cm]")
aY <- list(title = "Temperature [K]")
# Weird but you need to use t(z) here:
z <- t(z)
# Color plot
plot_ly(x=x,y=y,z=z,type = "heatmap",colors=colors) %>% 
   layout(xaxis = aX, yaxis = aY)
```
Or, very cool, an interactive surface plot:
```{r, out.width='100%', message = FALSE, warning = FALSE, fig.asp=.9,cache=FALSE}
plot_ly(x=x,y=y,z=z,type = "surface",colors=colors) %>%
   layout(scene = list(xaxis = aX, yaxis = aY, dragmode="turntable"))
```


### 2D density of points

In case you want to plot a density of points, you have a variety of solutions:
```{r}
df <- tibble(x=rnorm(1e3, mean=c(1,5)),
             y=rnorm(1e3, mean=c(5,1)))
p1 <- ggplot(data=df, aes(x=x,y=y))+ geom_density2d() + ggtitle('geom_density2d()')
p2 <- ggplot(data=df, aes(x=x,y=y))+ geom_hex() + ggtitle('geom_hex()')
p3 <- ggplot(data=df, aes(x=x,y=y))+ geom_bin2d() + ggtitle('geom_bin2d()')
p4 <- ggplot(data=df, aes(x=x,y=y))+ ggtitle('stat_density2d()') +
        stat_density2d(aes(fill = ..density..), geom = "tile", contour = FALSE, n = 200) +
        scale_fill_continuous(low = "white", high = "dodgerblue4")
library(cowplot)
plot_grid(p1,p2,p3,p4)
```


Or the base `smoothScatter()` function could do the trick:
```{r}
smoothScatter(df)
```





## Exercises

<details>
    <summary>**Exercise 1**</summary>

- Download the two sample Raman spectra: <a href="Data/PPC60_G_01.txt" download target="_blank">PPC60_G_01.txt</a> and <a href="Data/PPC60_G_30.txt" download target="_blank">PPC60_G_30.txt</a>
- Load them in two separate `data.frame`
- Plot them together using base graphics, one in red lines, one in blue points
    + Is the y axis alright? correct it if needed
- Add the corresponding legend where you see fit (*e.g.* top left corner)
- Create a function `norm01` to normalize data to [0,1]
- Do the same plot with data normalized to [0,1]
- Play with the theme to reproduce the following plot:

```{r, echo=FALSE}
# Load them in two separate `data.frame`
df1 <- read.table("Data/PPC60_G_01.txt", col.names=c("w","Int"))
df2 <- read.table("Data/PPC60_G_30.txt", col.names=c("w","Int"))
# Plot them together using base graphics, one in red lines, one in blue points
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
par(family = "Times", cex.lab=1.5, cex.axis=1.4, 
    mgp = c(2.4, .5, 0), tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(df1$w, norm01(df1$Int),
    xlab="Raman Shift [1/cm]",
    ylab="Intensity [arb. unit]",
    type="l", 
    col="red", 
    ylim=c(0,1), 
    lwd=3)
points(df2$w, norm01(df2$Int), col="royalblue", pch=16, cex=1)
axis(3, labels=FALSE)
axis(4, labels=FALSE)
legend("topleft",
    cex=1.4,
    lty=c(1, NA),
    lwd=c(3, NA),
    pch=c(NA, 16),
    col=c("red", "royalblue"),
    bty = "n",
    legend=c("PPC60_G_01", "PPC60_G_30")
    )
```

- Gather the two `data.frame` in a single tidy one, and do an equivalent plot in `ggplot2`
- What are the difficulties you encountered in each case (base graphics and ggplot)? You now see that each graphics has its perks and downsides.


<details>
    <summary>Solution</summary>

```{r}
# Load them in two separate `data.frame`
df1 <- read.table("Data/PPC60_G_01.txt", col.names=c("w","Int"))
df2 <- read.table("Data/PPC60_G_30.txt", col.names=c("w","Int"))
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
# Plot them together using base graphics, one in red lines, one in blue points
par(family = "Times", cex.lab=1.5, cex.axis=1.4, 
    mgp = c(2.4, .5, 0), tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(df1$w, norm01(df1$Int),
    xlab="Raman Shift [1/cm]",
    ylab="Intensity [arb. unit]",
    type="l", 
    col="red", 
    ylim=c(0,1), 
    lwd=3)
points(df2$w, norm01(df2$Int), col="royalblue", pch=16, cex=1)
axis(3, labels=FALSE)
axis(4, labels=FALSE)
legend("topleft",
    cex=1.4,
    lty=c(1, NA),
    lwd=c(3, NA),
    pch=c(NA, 16),
    col=c("red", "royalblue"),
    bty = "n",
    legend=c("PPC60_G_01", "PPC60_G_30")
    )
# Gather them in a single tidy `data.frame`, and do the same in `ggplot2`
df1$name <- "PPC60_G_01"
df1$norm <- norm01(df1$Int)
df2$name <- "PPC60_G_30"
df2$norm <- norm01(df2$Int)
df <- rbind(df1, df2)
library(ggplot2)
ggplot(df, aes(x=w, y=norm)) +
    geom_line(data=subset(df, name=="PPC60_G_01"), size=1, aes(color=name))+
    geom_point(data=subset(df, name=="PPC60_G_30"), size=2, aes(color=name))+
    scale_color_manual(values=c("red","royalblue"), name="") +
    labs(x="Raman Shift [1/cm]", y="Intensity [arb. unit]") +
    theme_bw() +
    theme(legend.position = c(0.15,.92),
          text = element_text(size = 16,family = "Times"),
          axis.text = element_text(size = 16),
          legend.text = element_text(size = 14),
          panel.grid.major = element_blank(), 
          panel.grid.minor = element_blank())
```


</details>

</details>


<details>
    <summary>**Exercise 2**</summary>

Using `df <- data.frame(x=rnorm(1e4), y=rnorm(1e4))`, try reproducing the following plots using `ggplot2`:

```{r, echo=FALSE, warnings=FALSE}
N    <- 1e4
df   <- data.frame(x=rnorm(N), y=rnorm(N))
df$z <- 0
df$z[df$x<0 & df$y<0] <- 1
df$z[df$x>0 & df$y<0] <- 2
df$z[df$x>0 & df$y>0] <- 3
p1 <- ggplot(data=df[1:100,], aes(x=1:100, y=x)) + geom_line() + xlab("Index")
p2 <- ggplot(data=df, aes(x=x,y=y)) + geom_point(alpha=0.2)
p3 <- ggplot(data=df, aes(x=x,y=y, color=z)) + geom_point(alpha=0.5) + theme_light() + theme(legend.position = "none")
p4 <- ggplot(data=df, aes(x=x,y=y)) + geom_hex() + theme(legend.position = "none")
p5 <- ggplot(data=df, aes(x)) + geom_histogram()
p6 <- ggplot(data=df, aes(x)) + geom_density(fill="royalblue", color="royalblue", alpha=0.2)
plot_grid(p1, p2, p3, p4, p5, p6, labels="auto")
```


</details>


<details>
    <summary>**Exercise 3**</summary>


- Download <a href="Data/population.csv" download target="_blank">population.csv</a> and load it into a `data.frame`
- Is it a tidy `data.frame`?
    + Do we want a tidy `data.frame`?
    + Why?
    + Act accordingly
- Plot the population vs. year with a color for each city
    + With points
    + With lines
    + With a black and white theme
    + Change the axis labels to "Year" and "Population"
    + Make it interactive
- Try reproducing the following plots (Google is your friend):

```{r echo=FALSE}
df <- read.csv("Data/population.csv")
library(tidyr)
df <- gather(df, names(df)[-1], key="City", value="Population")
df$City <- gsub("\\.", " ", df$City)
names(df)[1] <- "Year"
my_theme <- theme_bw()+
            theme(axis.text = element_text(size = 14,family = "Helvetica",colour="black"),
                  text = element_text(size = 14,family = "Helvetica"),
                  axis.ticks = element_line(colour = "black"),
                  legend.text = element_text(size = 10,family = "Helvetica",colour="black"),
                  panel.border = element_rect(colour = "black", fill=NA, size=1)
                  )
colors <- c("royalblue","red")
p1 <- ggplot(data=subset(df,City%in%c("Montpellier","Nantes")), aes(x=Year, y=Population, size=Population, color=City)) +
        geom_point() + 
        geom_smooth(method="lm", aes(fill=City), alpha=0.1, show.legend = FALSE) + 
        scale_color_manual(values=colors)+
        scale_fill_manual(values=colors)+
        ggtitle("Population in Montpellier and Nantes")+
        labs(x="Year", y="Population")+
        my_theme 
p1
p2 <- ggplot(data=subset(df,Year==2012), aes(x=reorder(City,-Population), y=Population/1e6, fill=Population/1e6)) +
        geom_bar(stat="identity", position="dodge") + 
        ggtitle("Population in 2012 (in millions)")+
        labs(x="", y="Population (in millions)")+
        scale_fill_gradientn(colors=colors, name="Population\n(in millions)") +
        my_theme + 
        theme(axis.text.x = element_text(angle = 45, hjust=1))
p2
p3 <- ggplot(data=subset(df,Year<2000), aes(x=City, y=Population/1e6, fill=City)) + 
        geom_bar(stat="identity") + 
        facet_wrap(~Year) +
        scale_x_discrete(labels = "") +
        my_theme + 
        labs(x = "", y="Population (in millions)") +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              strip.background = element_blank(),
              legend.key.height = unit(1,"line"),
              legend.key.size = unit(1,"line")
              )
p3
```


<br>
<br>
<details>
<summary>Solution</summary>

```r
# Load and tidy population data.frame
df <- read.csv("Data/population.csv")
library(tidyr)
df <- gather(df, names(df)[-1], key="City", value="Population")
df$City <- gsub("\\.", " ", df$City) # replace dots by spaces in city names
names(df)[1] <- "Year"
# Plot the population vs. year with a different color for each city
p <- ggplot(data=df, aes(x=Year, y=Population, color=City))
# With points
p + geom_point()
# With lines
p + geom_line()
# With a black and white theme
# Change the axis labels to "Year" and "Population"
p <- p + geom_line() + theme_bw() + xlab("Year") + ylab("Population"); p
# Make it interactive
library(plotly)
ggplotly(p)
# Reproduce the plots
my_theme <- theme_bw()+
            theme(axis.text = element_text(size = 14,family = "Helvetica",colour="black"),
                  text = element_text(size = 14,family = "Helvetica"),
                  axis.ticks = element_line(colour = "black"),
                  legend.text = element_text(size = 10,family = "Helvetica",colour="black"),
                  panel.border = element_rect(colour = "black", fill=NA, size=1)
                  )
colors <- c("royalblue","red")
p1 <- ggplot(data=subset(df,City%in%c("Montpellier","Nantes")), 
                aes(x=Year, y=Population, size=Population, color=City)) +
        geom_point() + 
        geom_smooth(method="lm", aes(fill=City), alpha=0.1, show.legend = FALSE) + 
        scale_color_manual(values=colors)+
        scale_fill_manual(values=colors)+
        ggtitle("Population in Montpellier and Nantes")+
        labs(x="Year", y="Population")+
        my_theme 
p1
p2 <- ggplot(data=subset(df,Year==2012), 
                aes(x=reorder(City,-Population), y=Population/1e6, fill=Population/1e6)) +
        geom_bar(stat="identity", position="dodge") + 
        ggtitle("Population in 2012 (in millions)")+
        labs(x="", y="Population (in millions)")+
        scale_fill_gradientn(colors=colors, name="Population\n(in millions)") +
        my_theme + 
        theme(axis.text.x = element_text(angle = 45, hjust=1))
p2
p3 <- ggplot(data=subset(df,Year<2000), aes(x=City, y=Population/1e6, fill=City)) + 
        geom_bar(stat="identity") + 
        facet_wrap(~Year) +
        scale_x_discrete(labels = "") +
        my_theme + 
        labs(x = "", y="Population (in millions)") +
        theme(axis.text.x = element_blank(),
              axis.ticks.x = element_blank(),
              strip.background = element_blank(),
              legend.key.height = unit(1,"line"),
              legend.key.size = unit(1,"line")
              )
p3
```

</details>
</details>






# Fitting




## Linear fitting


Let's learn how to do simple fits with R and plot the results.
```{r, warnings=FALSE}
# Create some fake data
d <- read.table(header=TRUE,text="
   x           y
   39.11       6.67
   46.1        10.8
   52.02       16.36
   56.07       23.16
   61.00       26.5
   65.26       31.3
   69.16       33.5
   74.00       41.0
   81.70       50.3
   ")
# Fit with a linear model
fit <- lm(y~x, data=d)
# Summary of the fit
summary(fit)
attributes(fit)
# Retrieve the coefficients and errors
coef(fit); coef(fit)[1]; coef(fit)['(Intercept)']
summary(fit)$coefficients; summary(fit)$coefficients["x","Std. Error"]
# Plotting the points and the fit
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(d, pch=16)
abline(coef(fit), col="red")
to_print <- paste("y = ", round(coef(fit)[1],2)," + x*",
                    round(coef(fit)[2],2), sep="")
text(50, 50, to_print)
ggplot(data=d, aes(x,y)) + 
    geom_point(cex=3) +
    geom_smooth(method="lm") +
    annotate("text", x = 50, y = 50, label = to_print)
```

The function `geom_smooth()` will fit the data and display the fitted line, but to retrieve the actual coefficients you still need to run `lm()`.


## Non linear fitting


You can fit data with your own functions and constraints using `nsl`. Example:

### Base R

```{r, warnings=FALSE}
# Create fake data
x  <- seq(-7,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10
df <- data.frame(x=x,y=y)
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit <- nls(y ~ myfunc(x, y0, x0, A, B),
           data=df,
           start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
           )
summary(fit)
x0 <- coef(fit)["x0"]; y0 <- coef(fit)["y0"]
A  <- coef(fit)["A"];  B  <- coef(fit)["B"]
# Plotting the resulting function in red
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1))
lines(x, myfunc(x, y0, x0, A, B), col="red", lwd=2)
```

Or with `ggplot2`:

```{r}
ggplot(data=df, aes(x,y))+
    geom_point() +
    geom_smooth(method = "nls", 
                method.args = list(formula = y ~ myfunc(x, y0, x0, A, B),
                                   start=list(y0=0, x0=1.5, A=.2, B=.2)
                                   ), 
                data = df,
                se = FALSE,
                color="red")
```

In `nls` it is even possible to constraint the fitting by adding lower and upper boundaries. You have to be careful with these and not provide stupid ones, *e.g.*:

```{r, warnings=FALSE}
# Constraining the upper and lower values of the fitting parameters
fit2 <- nls(y~ myfunc(x, y0, x0, A, B),
           start=list(y0=0, x0=5, A=.2, B=.2),
           upper=list(y0=Inf, x0=Inf, A=.4, B=1),
           lower=list(y0=-Inf, x0=4, A=-Inf, B=-Inf),
           algorithm = "port"
           )
x0 <- coef(fit2)["x0"]; y0 <- coef(fit2)["y0"]
A  <- coef(fit2)["A"];  B  <- coef(fit2)["B"]
# Plotting the resulting function in blue
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1), main="Beware of constraints")
lines(x, myfunc(x, y0, x0, A, B), col="royalblue", lwd=2)
```

### FME

Some times though, whatever the initial conditions of the fit you use, you will get the error message `Error in nlsModel(formula, mf, start, wts) : singular gradient matrix at initial parameter estimates`. If playing around with the initial parameters does not solve this problem, a more robust fitting method is needed. A good one is `modFit()` from the package `FME`, that also accepts constraints. 

With `modFit`, the algorithm minimizes the residual of the observed data minus the model, so the syntax is slightly different:

```{r}
library(FME)
myfunc <- function(x, params) {
    parms <- as.list(params)
    parms$y0 + dnorm(x, sd=parms$A) + dnorm(x, mean=parms$x0, sd=parms$B)
}
params <- c(y0=0, x0=5, A=.2, B=.2) # initial guess
ModCost <- function(P) {
    return(y - myfunc(x, P)) # residuals
}
fit <- modFit(f = ModCost, p = params)
summary(fit)
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(x, y, pch=16, ylim=c(0,1.1), main="FME::modFit")
lines(x, myfunc(x,fit$par), col="royalblue", lwd=2)
```



## Exercises

<details>
    <summary>**Exercise 1**</summary>

- Load <a href="Data/exo_fit.txt" download target="_blank">exo_fit.txt</a> in a `data.frame`.
- Using `lm` or `nls` fit each column as a function of `x` and display the "experimental" data and the fit on the same graph.
    + Tip: Take a look at the function `dnorm` to define a Gaussian

<!-- ```{r}
x <- seq(-10,10,.1)
y <- 4*x+6+runif(length(x))*5
z <- 100*dnorm(x, mean=2.1,sd=2)+runif(length(x)) -.5
w <- sin(x/1.5)+runif(length(x))/2 -.5/2
u <- sin(x/1.5)+x*.2+runif(length(x))/5 -.5/5
df <- data.frame(x=x, y=y, z=z, w=w, u=u)
write.table(df, "Data/exo_fit.txt", quote=FALSE, row.names=FALSE)
``` -->


</details>


<details>
    <summary>**Exercise 2: application to real data**</summary>

- Load the Raman spectrum <a href="Data/rubis_01.txt" download target="_blank">rubis_01.txt</a>, normalize it to [0,1] and plot it
- Define the Lorentzian function
- Create a function that is the sum of 2 Lorentzians
- Guess grossly the initial parameters and plot the resulting curve
- Fit the data by a sum of 2 Lorentzians using `nls`
    + Try playing with the starting parameters to get rid of the error
- Define a function returning the sum of Lorentzians taking the parameters as a vector, `sumLor(x, params)`. 
- Define the `ModCost` function returning the residuals of the fit
- Use the same initial parameters as before and plot the initial guessed curve
- Fit the data using `FME::modFit()`
- What happens with the `y0` parameter? use a constraint to keep the parameters plausible
- Plot the resulting fit


<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, error=TRUE}
# Load rubis_1.txt, normalize it to [0,1] and plot it
d <- read.table("Data/rubis_01.txt", header=FALSE, col.names=c("w", "Int"))
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
d$Int_n <- norm01(d$Int)
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(d$w, d$Int_n)
# Define the Lorentzian function
Lorentzian <- function(x,x0=0,FWHM=1,A=1,y0=0){
    y0 + 2*A/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
# Create a function that is the sum of 2 Lorentzians
Lor2 <- function(x,x1,FWHM1,A1,y1,x2,FWHM2,A2,y2){
    Lorentzian(x,x0=x1,FWHM=FWHM1,A=A1,y0=y1) + 
    Lorentzian(x,x0=x2,FWHM=FWHM2,A=A2,y0=y2) 
}
# Guess grossly the initial parameters and plot the resulting curve
plot(d$w, d$Int_n)
lines(d$w,Lor2(d$w,x1=3160, FWHM1=10, A1=3, y1=0.03, 
                   x2=3200, FWHM2=10, A2=7, y2=0), col="red")
# Fit the data by a sum of 2 Lorentzians using `nls`
fit <- nls(data=d, Int_n ~ Lor2(w,x1,FWHM1,A1,y1,x2,FWHM2,A2,y2), 
           start=list(x1=3160, FWHM1=10, A1=3, y1=0.03,
                      x2=3200, FWHM2=10, A2=7, y2=0)
           )
# This doesn't work... we need to use a more robust fitting method
# Define a function returning the sum of two Lorentzians 
# taking the parameters as a vector, `sumLor(x, params)`
sumLor <- function(x,params){
    # sum of Lorentzian functions
    y0   <- as.numeric(params[grep("y0",names(params))])
    A    <- as.numeric(params[grep("A",names(params))])
    x0   <- as.numeric(params[grep("x0",names(params))])
    FWHM <- as.numeric(params[grep("FWHM",names(params))])
    if(length(x0)!=length(FWHM)) FWHM <- rep(FWHM, length.out=length(x0))
    if(length(x0)!=length(A))    A <- rep(A, length.out=length(x0))
    if(length(x0)!=length(y0))   y0 <- rep(y0, length.out=length(x0))
    rowSums(sapply(1:length(x0), function(i) {
          y0[i] + 2*A[i]/(pi*FWHM[i])/( 1 + ((x-x0[i])/(FWHM[i]/2))^2 )
        }))
}
# Define the `ModCost` function returning the residuals of the fit
ModCost <- function(P) {d$Int_n - sumLor(d$w, P)}
# Use the same initial parameters as before and plot the initial guessed curve
params <- c(x0=c(3160, 3200),
            FWHM=c(10,10), 
            A=c(3,7),
            y0=c(0.01,0.01))
par(cex.lab=1.5, cex.axis=1.4, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, 2, .5), lwd=2, las=1)
plot(d$w, d$Int_n, pch=16, col=adjustcolor("black", alpha=.5), cex=1)
lines(d$w, sumLor(d$w, params), col="blue")
# Fit the data using `FME::modFit()`
# What happens on the `y0` parameter? use a constraint to keep the parameters plausible
library(FME)
fit <- modFit(f=ModCost, p=params, lower=c(x0=c(0,0), A=c(0,0), FWHM=c(0,0),y0=c(0,0)))
# Plot the resulting fit
lines(d$w, sumLor(d$w, coef(fit)), col="red")
```

</details>
</details>













# Practical case: recursive data treatment




Here I will provide an example workflow for treating large amounts of experimental measurements. There are many ways of doing this, this is just a working example. 

You will find [here](../Data/XP_data.zip) the corresponding experimental data.

My way of doing things – again, maybe not the best, but it's what I do – is that for each experiment I create a folder containing at least 4 objects:

- `log.Rmd`: the markdown or R notebook in which I treat the data. I can produce a pdf or html document from it. We will see about that in the next section.
- `myfunc.R`: my user-defined functions that I can load in my working environment using `source(myfunc.R)`
- `Data/`: folder containing the original data (usually ASCII files) that I _never modify_ (reproducible data treatment and all that)
- `Plots/`: folder containing the static (pdf) plots produced with `log.Rmd`

So, let's begin. First we set up our working environment:

```{r, warnings=FALSE, include=FALSE}
# Set the working directory
setwd("/Users/colin/Travail/Enseignements/R/")
# and load the user-defined functions
source("myfunc.R")
```
```r
# Set the working directory
setwd("/Users/colin/Travail/Enseignements/R/")
# and load the user-defined functions
source("myfunc.R")
```

In the working directory, we create a folder `Data` in which we extract the [XP_data.zip](../Data/XP_data.zip) archive. It contains a number of txt files named `rubis_XX.txt`. They are Raman spectra of ruby chips under pressure used for the calibration of pressure in a diamond anvil cell, their shift is directly correlated to the pressure in the DAC.

First, let's list all these files:
```{r, warning=FALSE}
# Find all the files in "Data"
frubis <- list.files(path="Data", pattern = "rubis")
head(frubis)
length(frubis)
# Create a tibble to store each spectra
library(tidyverse)
spec <- tibble()
# and a data.frame to store the fit parameters
fitpar <- data.frame()
```

Now let's read the data, store them in the tibble `spec` together with other informations, such as the name of the file, the fitted curves of the peaks, or the obtained pressure (the function `Pruby()` is defined in `myfunc.R`).

```{r, out.width='100%', fig.asp=.85,cache=FALSE, warning=FALSE}
# Reading and storing all treated data 
for(i in seq_along(frubis)){#i <- 1
    # Reading raw data
    d <- read.table(file.path("Data",frubis[i]),sep="\t")
    names(d) <- c("w", "Int")
    # Fitting two Lorentzians using the previously defined functions
    # sumLor is defined in "myfunc.R"
    # Initial guess of the position and parameters:
    xmax   <- d$w[which.max(d$Int)] 
    params <- c(x0=c(xmax, xmax-30),
                FWHM=c(10,10), 
                A=c(3,7),
                y0=c(0.01,0.01))
    # Fit the data
    ModCost <- function(param) {d$Int - sumLor(d$w, param)}
    fit <- modFit(f=ModCost, p=params, 
                  lower=c(x0  =c(0,0), 
                          A   =c(0,0), 
                          FWHM=c(0,0),
                          y0  =c(0,0))
                  )
    # Compute the various components of the fit
    y1   <- sumLor(d$w, c(x0=coef(fit)['x01'], FWHM=coef(fit)['FWHM1'],
                           A=coef(fit)['A1'], y0=coef(fit)['y01']))
    y2   <- sumLor(d$w, c(x0=coef(fit)['x02'], FWHM=coef(fit)['FWHM2'],
                           A=coef(fit)['A2'], y0=coef(fit)['y02']))
    ytot <- y1+y2
    # Store all the data and fits in a tidy tibble
    spec <- rbind(spec, tibble(w      = d$w,
                               Int    = d$Int, 
                               Int_n  = d$Int/max(d$Int), 
                               y1     = y1,
                               y1_n   = y1/max(d$Int),
                               y2     = y2,
                               y2_n   = y2/max(d$Int),
                               ytot   = ytot,
                               ytot_n = ytot/max(d$Int),
                               name   = gsub(".txt","",frubis[i]),
                               P      = round(Pruby(coef(fit)['x01']),2)
                               )
                 )
    # Store the fitting parameters in a tidy data.frame
    fitpar <- rbind(fitpar, data.frame(param=names(coef(fit)),
                                       fit=coef(fit),
                                       name=gsub(".txt","",frubis[i]),
                                       P=round(Pruby(coef(fit)['x01']),2)
                                       )
                    )
    # Uncomment and plot to check if everything is OK:
    # j <- i
    # ggplot(data=subset(spec, name==gsub(".txt","",frubis[j])),aes(x=w)) +
    #   ggtitle(gsub(".txt","",frubis[j]))+
    #   geom_point(aes(w,Int))+
    #   geom_line(aes(w,ytot),color="red")+
    #   geom_area(aes(w,y1),fill="orange", alpha=0.1)+
    #   geom_area(aes(w,y2),fill="royalblue", alpha=0.1)+
    #   theme_bw()
}
```

Now let's take a global look at our data. For this I like the slider functionality of `plotly`. Make your `ggplot` as usual, and just add the keyword `frame` that is read by `ggplotly()`:

```{r, out.width='100%', fig.asp=.85,cache=FALSE, warning=FALSE}
gg <- ggplot(data=spec,aes(x=w)) +
          labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
          geom_point(aes(x=w, y=Int_n, frame=P))+
          geom_line(aes(x=w,y=ytot_n, frame=P),color="red")+
          geom_line(aes(x=w,y=y1_n, frame=P),color="royalblue", alpha=0.5)+
          geom_line(aes(x=w,y=y2_n, frame=P),color="orange", alpha=0.5)+
          theme_bw()
ggplotly(gg) %>%
  animation_opts(5)%>%
  animation_slider(
    currentvalue = list(prefix = "Pressure: ", 
                        suffix = " GPa", font = list(color="red"))
  )
```

<br>
In case you want to save all the plots in a pdf file, you'd do something like that:

```r
pdf("Plots/plots_fits.pdf",height=6, width=8)
for(f in frubis){
    p <- ggplot(data=subset(spec, name==gsub(".txt","",f)),aes(x=w)) +
            geom_point(aes(w,Int))+
            labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
            ggtitle(gsub(".txt","",f))+
            geom_line(aes(w,ytot),color="red")+
            geom_area(aes(w,y1),fill="orange", alpha=0.1)+
            geom_area(aes(w,y2),fill="royalblue", alpha=0.1)+
            theme_bw()
    print(p)
}
dev.off()
```

where the line `print(p)` is necessary, since `ggplot` does not output plots when embedded in a for loop.

Now we can also plot the evolution of the fit parameters. Let's only look at the position of the peaks:

```{r, out.width='100%', fig.asp=.85,cache=FALSE, warning=FALSE}
p <- ggplot(data=fitpar, aes(x=name, y=fit)) +
            geom_point(data=subset(fitpar, param=="x01"), size=2)+
            geom_point(data=subset(fitpar, param=="x02"), color="red", size=2)+
            theme_bw() +
            theme(axis.text.x = element_text(angle = 45, hjust=1))
ggplotly(p)
```

And *voilà*! in a few lines of code, you have treated a number of spectra in the same manner, plotted the fits, obtained the fitting parameters and deducted the corresponding pressure.

You are now ready to get to work!





# Writing documents with Rmarkdown

## What is markdown?

Markdown is a simplified language that can be used to produce a variety of rich documents: a single .md file can be compiled and outputted to .docx, .odt, .html, .rtf, .pdf or .tex. This output format as well as various options (font size, template, table of contents, numbered sections...) are specified in a YAML header, *i.e.* text between two lines like that `---` (we'll see an example later).

In markdown can be embedded $\LaTeX$ code for displaying math expressions, html tags for more complicated html stuff, and the rest of the formatting is given by a few easy commands:

```
# Title
## sub-title
### sub-sub-title
...
###### sub_6-title
**bold**
*italic*
[link](http://google.com/)
![image caption](image.png)
Table:
|   |   |
|---|---|
|   |   |
Unordered list:
- bla
- bla bla
Ordered list:
1. bla
1. bla bla
```

You can also add in-line code by writing text between back-ticks:
```markdown
Text with `in-line code`
```
will render as: Text with `in-line code`

For more commands, you can for example get a digested cheat-sheet [here](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) and a tutorial [here](http://www.markdowntutorial.com/).

## ... and Rmarkdown?

Rmarkdown is basically the same thing as markdown (extension: .Rmd instead of .md), with the difference that code chunks in which you specify the language between accolades *will be computed and the result will be displayed*.

````
```r
# Not computed
1+1
```
````

````r
`r ''````{r}
# Computed
1+1
```
````
```{r, echo=FALSE}
1+1
```

And in-line code can be computed and rendered:
```markdown
In-line code ``r ''`r 1+2`
```
will render as: In-line code `r 1+2`.

This very webpage is fully written in Rmarkdown (you can download the Rmd file if you click the link in the top banner).

Rmarkdown supports a number of languages:
```{r}
names(knitr::knit_engines$get())
```

And `python` and `R` code chunks can communicate thanks to the `reticulate` package.

So... are you starting to see the power of this tool...?

Basically, you can use the best language for each task and combine it in a single Rmd file that will display text and images that are computed at each compilation of the Rmd file: you can fully automatize your data treatment and reporting. 

Example:

- chunk 1: bash, call a program that creates some files
- chunk 2: python, call a program that do some big computation on these files
- chunk 3: r, plot the data


## Further reading

To see all about Rmarkdown and combining languages in a single document:

- [code chunks](https://bookdown.org/yihui/rmarkdown/r-code.html)
- [languages](https://bookdown.org/yihui/rmarkdown/language-engines.html)
- [Rmarkdown cheatsheet](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)
- [Rmarkdown cookbook](https://dr-harper.github.io/rmarkdown-cookbook/index.html)

## Example

Create an _example.Rmd_ file with the following YAML header (**the indentation is important**):

```yaml
---
title  : Your Title
author : John Doe
date   : `r format(Sys.time(), '%d/%m/%Y')`
output :
    word_document:
        reference_docx: path/to/word-template.docx
        pandoc_args: ["--filter", "pandoc-fignos"]
    pdf_document:
        latex: xelatex
        fig_caption: true
        keep_tex: true
        pandoc_args: ["--filter", "pandoc-fignos"]
    beamer_presentation:
        keep_tex: true
    html_document:
        toc: yes
        highlight: tango
        number_sections: false
        pandoc_args: ["--filter", "pandoc-fignos"]
    html_notebook:
        toc: yes
        highlight: tango
        number_sections: false
        pandoc_args: ["--filter", "pandoc-fignos"]
bibliography: "path/to/biblio.bib"
csl: "path/to/nature.csl"
---
```

How to understand this header:

- `---`: surrounds the YAML header. The body comes after that.
- `title`, `author` and `date`: easy. The date can automatically be set to the current one by setting it to:
```
``r ''`r format(Sys.time(), '%d/%m/%Y')`
```
- `output`: this tells pandoc the output format you want. When compiling, the compiler will only look to the _**first**_ entry -- in this case, `word_document`. So you don't need to put all these entries if you want a clean(er) code, but I like to have all these output possibilities written there, then I just have to switch the first entry to the one I want when I want to change the output format. The difference between `html_document` and `html_notebook` is that in notebooks you can fold/unfold the code chunks.
    + `reference_docx`: tells pandoc the reference style (template) to use. Just write a dummy .docx file in which you [edit the style](http://www.dummies.com/software/microsoft-office/word/how-to-change-an-existing-style-in-word-2016/), save it as `word-template.docx`, and you're good to go.
    + `latex`: the $\LaTeX$ engine. You can also use pdflatex, for example.
    + `keep_tex`: when pandoc compiles your markdown file to a PDF, it goes through the intermediate step of creating a .tex file. You can decide to keep it for tweaking the style of the PDF output, like you would normally do with a .tex file.
    + `fig_caption`: allows for figure caption.
    + `toc`: creates a table of contents.
    + `number_sections`: allows for section numbering.
    + `highlight`: syntax highlighting theme for the code chunks.
    + `pandoc_args`: add pandoc-eqnos or pandoc-tablenos if you want to number equations or tables.
- `bibliography`: path to your .bib file. To create a bibliography, add a ```# References``` header at the end of your document.
- `csl`: path to the bibliography style for the output -- in this example, _nature.csl_. [Find your style](https://www.zotero.org/styles) or edit your own. 
- There are many [other options](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf), but with this you'll fulfill most of your needs.


Now you can start adding some content, like:
````markdown
---
title: "The title"
output: html_document
---

# First section
## First subsection
I am writing _italic_ and __bold__ stuff.

- This is an item
- This is another item with a citation [@Bibkey]

# Second section
## First subsection

This is a text with a footnote[^1].

This is an image with a caption:

![Image with a caption](https://cdn.foliovision.com/images/2017/03/i-love-markdown.png)

While this image has no caption 
![Image with no caption because I didn't skip a line](http://markdown-here.com/img/icon256.png)

Here's a code chunk in R:
`r ''````{r}
x <- seq(0,10,.1)
plot(x, sin(x))
```
And one in python:
`r ''````{python}
x = 1+1
```

# References

[^1]: This is a footnote.
```` 

Note that when you choose to output to an html format, you can't use PDF images: use .svg ([pdf2svg](http://www.cityinthesky.co.uk/opensource/pdf2svg/)) or other non vectorial images. 

What's nice with html output, it's that you can include _interactive_ figures with `plotly` like we saw in the previous sections. Of course, this won't work with static documents like PDF or Word...

For cross referencing to figures and tables, use `output: bookdown::html_document2` instead of `output: html_document` (requires the package `bookdown`), and see [here](https://dr-harper.github.io/rmarkdown-cookbook/crossRef.html) for details.

## Compilation

To knit your Rmd file to the desired output, in Rstudio, click the little triangle next to the "Knit" button, like this:

[![](img/compile_rmd.png)](img/compile_rmd.png)

The corresponding output file will be created in the same folder.

## Going further: parameters

You can even provide a list of parameters to your Rmarkdown file that you can retrieve in code chunks with `params$param_name`. More information [here](https://bookdown.org/yihui/rmarkdown/parameterized-reports.html), but here is a short example: try compiling it directly using the "Knit" button, and then try compiling it using "Knit with parameters".


````markdown
---
title: "Test"
output: html_document
params:
  city:
    label: "City:"
    value: Angers
    input: select
    choices: !r unique(read.table("Data/population.txt", header=TRUE)$city)
  printcode:
    label: "Display Code"
    value: TRUE
  data:
    label: "Input dataset:"
    value: Data/population.txt
    input: file
---

`r ''````{r, setup, include=FALSE}
# set this option in the first code chunk in the document
knitr::opts_chunk$set(echo = params$printcode)
```

Plotting ``r ''`r paste(params$data)`:

`r ''````{r, message=FALSE}
df <- read.table(params$data, header=TRUE)
library(ggplot2)
library(plotly)
p<-ggplot(data=subset(df,city==params$city), 
            aes(x=year, y=pop, size=pop)) +
        geom_point() + 
        geom_smooth(method="lm", alpha=0.1, show.legend = FALSE) + 
        ggtitle(paste("Population in ",params$city,sep=""))+
        labs(x="Year", y="Population")+
        theme_light()
ggplotly(p)
```
````


The "Knit with parameters" launches a `Shiny` user interface allowing interactively choosing the parameters. All options are listed [here](https://bookdown.org/yihui/rmarkdown/params-knit.html#the-interactive-user-interface).



## And what about JuPyteR notebooks?

[JuPyteR notebooks](https://jupyter.org/) (for Julia, Python and R) are basically a web-based interactive version or Rmarkdown documents working with **Ju**lia, **Pyt**hon and **R**. 

But the installation is a tad complicated for the non initiate, and, well, it is just like Rmarkdown but less easy to use and share, in my opinion. But if you mostly work with python, then you have to get used to it since Rmarkdown is better suited for R.


## Exercise

<details>
    <summary>**Exercise 1**</summary>

Create a new Rmd document in Rstudio, fill it with what you want, and output it in different formats.

</details>


<details>
    <summary>**Exercise 2**</summary>

Create an html experimental logbook doing all the data treatment in the example in the previous section.

</details>


<details>
    <summary>**Exercise 3**</summary>

Create an html experimental **notebook** doing all the data treatment in the example in the previous section **for a single experimental file** that you will provide as a parameter in the YAML header. The file path must be given as an interactive file input selection.

</details>








# Graphical interfaces with Shiny


You have had a preview of a `shiny` interface in the previous section with the interactive parameter input in a Rmarkdown file.

Using the `shiny` package, you can actually easily build an interactive graphical user interface (GUI) in which you will be able to set parameters (values, files...), visualize the outputs (plots, images, tables...), and write files as output. This is very useful when you have to always repeat the same task with a varying input parameter, for example.

## Stand-alone shiny application

A shiny application is an `app.R` file (it must be named like that) containing 3 elements:

1. `ui`: definition of the interface layout (where are the buttons, text input, plot output, etc.) and the input parameters
2. `server`: definition of the various actions to perform with the input parameters
3. `shinyApp(ui, server)`: launches the shiny app with the above defined parameters

In Rstudio, create a new "Shiny web app". It will create an `app.R` file containing this:

```r
library(shiny)
# Define UI for application that draws a histogram
ui <- fluidPage(
    # Application title
    titlePanel("Old Faithful Geyser Data"),
    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),
        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)
# Define server logic required to draw a histogram
server <- function(input, output, session) {
    output$distPlot <- renderPlot({
        # generate bins based on input$bins from ui.R
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # draw the histogram with the specified number of bins
        hist(x, breaks = bins, col = 'darkgray', border = 'white')
    })
}
# Run the application 
shinyApp(ui = ui, server = server)
```

Run it by clicking "Run App": a window opens and you can pan the slider and see the resulting output.

In case you want to clean up the code, you can separate `app.R` into `ui.R` and `server.R`. No need to add the `shinyApp(ui = ui, server = server)` line in that case.

All user-defined functions and variable definitions can be defined in a `global.R` file that will be sourced by default when launching the app.


### The layout

In the `ui <- fluidPage(...)` item, you define the layout of your application. In the above example:

- `titlePanel("Title")` creates a title
- `sidebarLayout()` separates the layout in a short one on the left (`sidebarPanel`) and a main one on the right (`mainPanel`)
- `sliderInput("name_of_slider", "text to display", min=min_value, max=max_value, value=current_value, step=step_value)` creates a slider to input a value. This value will be retrieved by `input$name_of_slider` in the `server()` function.
- `plotOutput("name_of_plot")` plots the result of `output$name_of_plot` defined in the `server()` function.

See the [guide to application layout](https://shiny.rstudio.com/articles/layout-guide.html) for more layout options.

### The server

In the `server <- function(input, output){...}` function, you define the various actions and outputs in reaction to an input change. 

In the above example, we define `output$distPlot` as a `renderPlot()` function whose results depends on `input$bins`. The plot is rendered in the `ui` by `plotOutput("distPlot")`.

### Various useful functions

#### Input

- **Buttons**: 

```r
# # # # # # # # # 
# In ui:
actionButton("button_name", "Text to display")
# # # # # # # # # 
# In server:
observeEvent(input$button_name, {
    # do something
})
# or
some_function <- eventReactive(input$button_name, {
                               # do something
                               })
```

- **Text/numeric**: 

```r
# # # # # # # # # 
# In ui:
textInput("text_name", 
            label = "Text to display", 
            value = "initial value", 
            width = '100%')

textAreaInput("text_name", 
            label="Text to display", 
            value = "initial_value", 
            rows = 5) %>%
            shiny::tagAppendAttributes(style = 'width: 100%;')

numericInput("value_name", 'Text to display', value=0)
# # # # # # # # # 
# In server, retrieve it as:
input$text_name
input$value_name
```

- **Slider**

```r
# # # # # # # # # 
# In ui:
sliderInput("slider_name", "Text to display",
            min = 1,
            max = 50,
            step= 1,
            value = 30)
# # # # # # # # # 
# In server, retrieve it as:
input$slider_name
```

- **File**

```r
# # # # # # # # # 
# In ui:
fileInput("file_in", 
          "Choose input file:", accept = c(".txt") 
          )
# # # # # # # # # 
# In server, retrieve it as:
input$file_in$datapath
# For example, read it as a data.frame with myData():
myData <- reactive({
        inFile <- input$file_in
        if (is.null(inFile)) {
            return(NULL)
        } else {
            return(read.table(inFile$datapath, header=TRUE))
        }
    })
```

- **Dropdown menu**

```r
# # # # # # # # # 
# In ui:
selectInput("menu_name", "Text to display", 
            choices=c("choice 1", "choice 2"), 
            multiple = FALSE # multiple selection possible
            )
# # # # # # # # # 
# In server, retrieve it as:
input$menu_name
```

#### Output

- **Display a plot**

```r
# # # # # # # # # 
# In ui:
plotOutput("plot_name", height = 600)
# # # # # # # # # 
# In server:
output$plot_name <- renderPlot({
        # do plot:
        plot(...)
        # or
        ggplot(...)
    })
```

If you want an interactive plot, use `plotlyOutput` and `renderPlotly` instead.

- **Display text**

```r
# # # # # # # # # 
# In ui:
textOutput("text_to_display")
# Verbatim text (fixed width characters):
verbatimTextOutput("text_to_display")
# # # # # # # # # 
# In server:
output$text_to_display <- renderText({ "some text" })
output$text_to_display <- renderPrint({ "some text" })
```

- **Display a table**

```r
# # # # # # # # # 
# In ui:
tableOutput("table_to_display")
# # # # # # # # # 
# In server:
output$table_to_display <- renderTable( df )
```

Or in case you want interactive tables, use the package [datatable](https://shiny.rstudio.com/articles/datatables.html):
```r
library(DT)
# # # # # # # # # 
# In ui:
dataTableOutput("table_to_display")
# # # # # # # # # 
# In server:
output$table_to_display <- renderDataTable({ df })
```

- **Reactive events**

In case you want the plots or text display to react to a change in input value, you can wrap the corresponding output in the `reactive()` function on the server side:

```r
# # # # # # # # # 
# In ui:
fileInput("file_in", 
          "Choose input file:", accept = c(".txt") 
          )
selectInput("menu", "Columns to display", 
            choices=1:4, 
            multiple = TRUE)
tableOutput("table")
# # # # # # # # # 
# In server:
myData <- reactive({
        inFile <- input$file_in
        if (is.null(inFile)) {
            return(NULL)
        } else {
            return(read.table(inFile$datapath, header=TRUE))
        }
    })
tab <- reactive({
      myData()[,sort(input$menu)]
   })
output$table <- renderTable( tab() )
```

The various input default values can be updated using the following functions on the server side:

```r
# Dropdown menu
updateSelectInput(session, "menu_name", choices=new_choices)
# Text
updateTextInput(session, "text_name", value = new_value)
# Numeric
updateNumericInput(session, "value_name", value = new_value)
```


- **Writing a file**

This is not a function of shiny, but you may want to write a text file:

```r
toprint <- paste("hello", "world")
outfile <- file("file_name.txt", encoding="UTF-8")
write(toprint, file=outfile)
close(outfile)
```

You can for example write a Rmd file that you will render (as pdf, etc...) using [render()](https://www.rdocumentation.org/packages/rmarkdown/versions/1.13/topics/render):

```r
rmarkdown::render("file_name.Rmd")
```



### Example

Create a new shiny app with the following code, and play around with it. The input file should be the tidy <a href="Data/population.txt" download target="_blank">population.txt</a>.

```r
library(ggplot2)
library(shiny)
library(plotly)
library(tidyverse)
library(DT)

ui <- fluidPage(
    titlePanel("City population in France"),
    sidebarLayout(
        sidebarPanel(
            fileInput("file_in", "Choose input file:",
                      accept = c(".txt") ),
            selectInput("sel_city", "City:", choices = "", multiple = TRUE)
        ),
        mainPanel(
            tabsetPanel(
                tabPanel("Plot", plotlyOutput("cityplot", height = "800px")),
                tabPanel("Table", dataTableOutput("table"))
            )
        )
    )
)

server <- function(input, output, session) {
    
    # myData() returns the data if a file is provided
    myData <- reactive({
        inFile <- input$file_in
        if (is.null(inFile)) {
            return(NULL)
        } else {
            return(read.table(inFile$datapath, header=TRUE))
        }
    })
    
    # in case something changes, 
    # update the city input selection list
    observe({
        updateSelectInput(session, "sel_city",
                          choices = unique(myData()$city),
                          selected = unique(myData()$city)[1])
    })
    
    # plot the pop vs year for the selected cities
    output$cityplot <- renderPlotly({
        df <- myData()
        if(is.null(df)) return(NULL)
        p <- ggplot(data=subset(df, city %in% input$sel_city), 
                    aes(x=year, y=pop, size=pop, color=city)) +
            geom_point() + 
            geom_smooth(method="lm", alpha=0.1, show.legend = FALSE, 
                        aes(fill=city)) + 
            ggtitle(paste("Population in ",input$city,sep=""))+
            labs(x="Year", y="Population")+
            theme_light() +
            theme(legend.text = element_text(size = 16))
        ggplotly(p)
    })
    
    # show data as a table
    output$table <- renderDataTable({
        if(is.null(df)) return(NULL)
        spread(myData(), city, pop)
    }) 
    
}

shinyApp(ui = ui, server = server)
```


## Rmarkdown-embedded shiny application

A shiny application can even be embedded inside a Rmarkdown document by providing `runtime: shiny` in the YAML header. A short example here, try to compile it:

````markdown
---
title: "Test"
output: html_document
runtime: shiny
---

This is a test Rmarkdown document.

`r ''````{r, echo=FALSE, message=FALSE}
library(ggplot2)
library(plotly)
df <- read.table("Data/population.txt", header=TRUE)

shinyApp(
  ui = fluidPage(
    selectInput("city", "City:", choices = unique(df$city)),
    plotlyOutput("cityplot", height = 600)
  ),

  server = function(input, output) {
    output$cityplot = renderPlotly({
      p <- ggplot(data=subset(df,city==input$city), 
                aes(x=year, y=pop, size=pop)) +
            geom_point() + 
            geom_smooth(method="lm", alpha=0.1, show.legend = FALSE) + 
            ggtitle(paste("Population in ",input$city,sep=""))+
            labs(x="Year", y="Population")+
            theme_light()
      ggplotly(p)
    })
  }
)
```
````

The only "problem" with this solution is that the html file that is produced will not run the shiny app by itself, you have to open the Rmd file in Rstudio and hit "Run Document".

## Deploying your shiny app

There are 4 ways to deploy your app: passing the `app.R` file to your users, deploying to [shinyapps.io](https://www.shinyapps.io/), deploying on your own server, or building an executable with Electron.

### Passing the app.R file to your users

This option is certainly easy: just send your `app.R` file (or Rmd file with shiny embedded app) as well as any other files needed (*e.g.* `global.R`) to your users, explain to them how to run it, and *voilà*.

However, this needs a little bit of know-how from the users: they need to install R and Rstudio, install the needed packages, and run the app.

A good option to remove the "package-installing" step is to define a function `check.package()` that will check if the package is installed, install it if needed, and load it:

```r
check.packages <- function(pkg){
    new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
    if (length(new.pkg)) 
        install.packages(new.pkg, dependencies = TRUE)
    sapply(pkg, require, character.only = TRUE)
}
# Usage:
check.packages("ggplot2")
```


### Deploying to shinyapps.io

Applications deployed on shinyapps.io will be accessible from anywhere through a weblink. See for example [my application](https://cbousige.shinyapps.io/rubypressure/) to determine the pressure from a ruby Raman spectrum or the expected Raman shift for a given pressure and laser wavelength. Your application will however be public and you will have some limitations in the number of online applications and time of use (if you don't pay a fee, see [here](https://www.shinyapps.io/) for the various plans).

- First, create an account on [shinyapps.io](https://www.shinyapps.io/admin/#/signup)
- Follow the steps described [here](https://docs.rstudio.com/shinyapps.io/getting-started.html#deploying-applications) to:
    + *Configure RSconnect*: in your shinyapps.io dashboard, click your name, then Tokens, and create a token for a new app. Copy the text in the popup window.
    + *Deploy the app* from the Rstudio window by clicking on the "Publish" button in the top right corner of the interface. Follow the steps along the *shinyapps.io* way.

Note that in that case, you should not have any `install.package()` command in your code. Most packages are supported by shinyapps.io.


### Deploying on your own Linux server

This option is more advanced and I'm not going into details for that, but you have a number of tutorials online. See *e.g.* [here](https://shiny.rstudio.com/articles/shiny-server.html), [here](https://docs.rstudio.com/shiny-server/) or [here](https://www.digitalocean.com/community/tutorials/how-to-set-up-shiny-server-on-ubuntu-16-04).

You might consider this option if you work in a company that want to handle privately its data (which sounds plausible) and not pay the shinyapps.io fee to password protect the app. In that case, just work with the IT department to get it running.


### Building an executable

On **Windows**, there is this possibility that looks nice but that I never tried because I don't have Windows: [RInno](https://ficonsulting.github.io/RInno/).

On **any platform**: there is the possibility described [here](https://www.youtube.com/watch?v=ARrbbviGvjc) with the corresponding [github page](https://github.com/ColumbusCollaboratory/electron-quick-start). This option is actually awesome and a quite recent possibility. However, since the produced application will contain R and the needed packages, the executable file is quite heavy.




## Further reading

- The Shiny [cheatsheet](https://shiny.rstudio.com/images/shiny-cheatsheet.pdf)
- [Guide to application layout](https://shiny.rstudio.com/articles/layout-guide.html)
- The [Shiny Gallery](https://shiny.rstudio.com/gallery/): find what you want to do and adapt it to your needs
- The official [Shiny video tutorial](https://shiny.rstudio.com/tutorial/)



## Exercises

<details>
    <summary>**Exercise 1**</summary>

- Create a new empty app with a blank user-interface and run it.
- Add a title, a left panel and a main panel
- Add an input numerical value defaulting to 1 and with a step of 0.05, name it "bw"
- Add a slider input from 0 to 1e3 by steps of 1e2 defaulting to 5e2,  name it "N_val"
- Add a plot of the `density` of `rnorm(N_val)` with bandwidth `bw`
- Make sure `bw>0`, otherwise don't produce the plot

<details>
    <summary>Solution</summary>

```r
library(shiny)

ui <- fluidPage(
    titlePanel("Some title"),
    sidebarLayout(
        sidebarPanel(
            numericInput("bw", "Enter bandwidth:", 1, step=0.05),
            sliderInput("N_val", "Number of points:", 
                        min = 0, max = 1e4, step= 1e2, value = 5e2)
        ),
        mainPanel(
            plotOutput("plot", height = 600)
        )
    )
)

server <- function(input, output, session) {
    
    # plot the pop vs year for the selected cities
    output$plot <- renderPlot({
                        if(input$bw==0) return(NULL)
                        plot(density(rnorm(input$N_val), bw=abs(input$bw)))
                    })
}

shinyApp(ui = ui, server = server)
```

</details>
</details>




<details>
    <summary>**Exercise 2**</summary>

Create a shiny application that will:

- read an input (through a file dialog) Raman spectrum from a ruby (<a href="Data/XP_data.zip" download target="_blank">XP_data.zip</a>)
- fit the data by two Lorentzians
- plot the data interactively
- ask for the laser wavelength as an input and give 568.189 nm as default
- write the corresponding pressure on the page using the `Pruby()` function defined in `myfunc.R` found in <a href="Data/XP_data.zip" download target="_blank">XP_data.zip</a>.


</details>







